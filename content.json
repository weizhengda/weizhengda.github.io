{"meta":{"title":"魏正大的博客","subtitle":"小小的世界，大大的梦想","description":"JavaScript, Node.js","author":"魏正大","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-11-03T03:12:33.780Z","updated":"2018-11-03T03:12:33.780Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-03T03:04:47.000Z","updated":"2018-11-03T03:10:30.620Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-05-08T01:19:16.303Z","updated":"2019-05-08T01:19:16.303Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":"欢迎来到留言版。"}],"posts":[{"title":"使用 trash 避免 rm -rf 悲剧","slug":"使用-trash-避免-rm-rf-悲剧","date":"2019-04-24T10:04:26.000Z","updated":"2019-04-24T10:04:26.000Z","comments":true,"path":"2019/04/24/使用-trash-避免-rm-rf-悲剧/","link":"","permalink":"http://yoursite.com/2019/04/24/使用-trash-避免-rm-rf-悲剧/","excerpt":"昨晚做了一个令人痛心疾首的操作，rm -rf something，把我个人电脑里的重要文件夹给删掉了，懵逼了半天才缓过来。还好是个人文件，不对公司造成影响。这件事也让我意识到 rm -rf 确实是个高风险操作，文件备份也是重中之重。 为了规避这个风险操作，我决定用 trash 替代 rm，这样文件就不会直接被删除，而是进入废纸篓。","text":"昨晚做了一个令人痛心疾首的操作，rm -rf something，把我个人电脑里的重要文件夹给删掉了，懵逼了半天才缓过来。还好是个人文件，不对公司造成影响。这件事也让我意识到 rm -rf 确实是个高风险操作，文件备份也是重中之重。 为了规避这个风险操作，我决定用 trash 替代 rm，这样文件就不会直接被删除，而是进入废纸篓。 安装 trashtrash–CLI tool that moves files or folder to the trash 使用 homebrew 安装 trashbrew install trash 配置命令行安装完之后在 .zshrc 或者 .bashrc 添加以下配置，.Trash 是Mac下的废纸篓目录。 12345678alias rm=trashalias r=trashalias rl='ls ~/.Trash'alias ur=undelfileundelfile()&#123; mv -i ~/.Trash/$@ ./&#125; rm 或 r 命令可以把文件或者文件夹移入废纸篓。 rl 罗列出废纸篓内的文件。 ur 把废纸篓内的某个文件移动到当前位置，相当于恢复。","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"}]},{"title":"实现一个简单的WebSocket聊天室","slug":"实现一个简单的WebSocket聊天室","date":"2019-04-14T09:36:12.000Z","updated":"2019-04-14T09:36:12.000Z","comments":true,"path":"2019/04/14/实现一个简单的WebSocket聊天室/","link":"","permalink":"http://yoursite.com/2019/04/14/实现一个简单的WebSocket聊天室/","excerpt":"WebSocket 简介 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。","text":"WebSocket 简介 WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。 Web我们先用 express 搭一个基础的服务端。 创建 index.js 文件 12345678910var app = require('express')();var http = require('http').createServer(app);app.get('/', function(req, res)&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');&#125;);http.listen(3000, function()&#123; console.log('listening on *:3000');&#125;); run node index.js，并在浏览器打开 http://localhost:3000，访问成功即可看到 HTML设计我们的主页，实现一个简单的聊天窗口。 修改 index.js 123app.get('/', function(req, res)&#123; res.sendFile(__dirname + '/index.html');&#125;); 创建 index.html 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; font: 13px Helvetica, Arial; &#125; form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125; form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125; #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125; #messages li &#123; padding: 5px 10px; &#125; #messages li:nth-child(odd) &#123; background: #eee; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"messages\"&gt;&lt;/ul&gt; &lt;form action=\"\"&gt; &lt;input id=\"m\" autocomplete=\"off\" /&gt;&lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 重启应用并刷新页面你就可以看到一个如下图所示 Socket.io引入socket.io npm install --save socket.io 修改 index.js 123456789101112131415var app = require('express')();var http = require('http').Server(app);var io = require('socket.io')(http);app.get('/', function(req, res)&#123; res.sendFile(__dirname + '/index.html');&#125;);io.on('connection', function(socket)&#123; console.log('an user connected');&#125;);http.listen(3000, function()&#123; console.log('listening on *:3000');&#125;); 修改 index.html，在&lt;/body&gt;下添加如下代码 1234&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script&gt; var socket = io();&lt;/script&gt; 重启应用并刷新页面，就可以看到命令行打印如下 Emitting event当用户在聊天窗的输入框内输入，并提交时，触发 emit 事件，服务端监听到该事件并做出相应的反应。 修改 index.html 12345678910111213&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;&lt;script src=\"https://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; var socket = io(); $('form').submit(function(e)&#123; e.preventDefault(); // 防止页面重新加载 socket.emit('chat message', $('#m').val()); $('#m').val(''); return false; &#125;); &#125;);&lt;/script&gt; 服务端监听该事件，在 index.js 文件添加该代码 12345io.on('connection', function(socket)&#123; socket.on('chat message', function(msg)&#123; console.log('message: ' + msg); &#125;);&#125;); 展示消息当服务端收到用户A发出的消息，服务端重新发出该消息，让客户端接收，客户端监听到该事件后展示该条消息，就可以实现用户 A, B, C 都接收到该消息。 修改 index.js 12345io.on('connection', function(socket)&#123; socket.on('chat message', function(msg)&#123; io.emit('chat message', msg); &#125;);&#125;); 修改 index.html，实现消息的展示 1234567891011121314&lt;script&gt; $(function () &#123; var socket = io(); $('form').submit(function(e)&#123; e.preventDefault(); // prevents page reloading socket.emit('chat message', $('#m').val()); $('#m').val(''); return false; &#125;); socket.on('chat message', function(msg)&#123; $('#messages').append($('&lt;li&gt;').text(msg)); &#125;); &#125;);&lt;/script&gt; 重启应用并刷新页面，可以打开多个浏览器页面同时访问 localhost:3000，就可以体验简单聊天室的效果。 设置昵称 在每个用户进入的时候，随机生成一个数字作为用户的昵称，并且向所有用户广播该用户进入聊天室。当用户发送消息时，拼接上用户的昵称。 修改 index.js 12345678io.on('connection', (socket) =&gt; &#123; const nickname = 'user' + Math.ceil((Math.random() * 1000)) socket.broadcast.emit('connection', nickname + ' connected') socket.on('chat message', (msg) =&gt; &#123; io.emit('chat message', nickname + ': ' + msg) &#125;)&#125;) 修改 index.html，监听 connection 事件 1234567891011121314151617&lt;script&gt; $(() =&gt; &#123; const socket = io() $('form').submit((e) =&gt; &#123; e.preventDefault() socket.emit('chat message', $('#m').val()) $('#m').val('') return false &#125;); socket.on('chat message', (msg) =&gt; &#123; $('#messages').append($('&lt;li&gt;').text(msg)) &#125;) socket.on('connection', (msg) =&gt; &#123; $('#messages').append($('&lt;li&gt;').text(msg)) &#125;) &#125;); &lt;/script&gt; 重启应用并打开多个客户端，可以看到如下效果 参考资料本文大部分案例出自 socket.io 的入门文档 https://socket.io/get-started/chat/ https://en.wikipedia.org/wiki/WebSocket 廖雪峰官网 WebSocket 菜鸟教程 WebSocket","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://yoursite.com/tags/wechat/"}]},{"title":"微信支付开发实记","slug":"微信支付开发实记","date":"2018-11-19T08:50:48.000Z","updated":"2018-11-19T08:50:48.000Z","comments":true,"path":"2018/11/19/微信支付开发实记/","link":"","permalink":"http://yoursite.com/2018/11/19/微信支付开发实记/","excerpt":"微信支付分为JSAPI支付，扫码支付，APP支付，小程序支付等不同的支付方式。但大体的支付过程是一致的，本文以JSAPI支付，也就是微信内的H5支付为例，描述一下支付的整个开发流程。 配置商户需要提前开通商户平台，并去公众平台或开放平台提交微信支付申请，获得商户号和秘钥。 详细文档可以看这里","text":"微信支付分为JSAPI支付，扫码支付，APP支付，小程序支付等不同的支付方式。但大体的支付过程是一致的，本文以JSAPI支付，也就是微信内的H5支付为例，描述一下支付的整个开发流程。 配置商户需要提前开通商户平台，并去公众平台或开放平台提交微信支付申请，获得商户号和秘钥。 详细文档可以看这里 支付流程 微信支付的流程图画的很完整，开发前要把整个流程研究清楚。 整个流程，服务端需要做的有三件事。 前端支付按钮被触发后，服务端要去调用 统一下单 接口，把预付单信息、支付参数和参数签名返回给前端。前端根据这些参数唤起支付。 当用户支付成功后，微信会给我们一个回调通知，告知我们支付结果。这一步要实现“完成订单”操作，标记用户已经成功支付，进入“发货”流程。 提供一个查询接口，让前端再次确认是否支付成功。 统一下单在支付前，商户系统先调用该接口在微信支付后台生成预支付交易单，同样的，商户系统也需要在自己的表里记录一笔“未完成订单”。生成之后返回正确的预付单信息、支付参数和参数签名返回给前端。前端根据这些参数唤起支付。 接口 https://api.mch.weixin.qq.com/pay/unifiedorder参数巨多，具体还是看文档 这里需要说明的一点是，我们在调用这个接口时，需要签一次名用来给微信做校验，微信也返回了一个新的签名用来给我们做校验，然后我们还要返回给前端一个签名，用来唤起支付。这三个签名都不是同一个。 我们不能直接把调用统一下单接口返回的签名返回给前端，而是根据前端唤起支付的参数去重新签名。 注意，是根据前端唤起支付的参数去重新签名，因为前端的参数名和后端的参数名会略微有差别，这里需要小心。 说明：签名的意图是用来校验身份，当前端把这些参数传给微信，微信会把调用参数除去签名后重新签名，用来校验签名的正确性，所以用来签名的参数名要和前端参数一致。 支付结果通知在统一下单时我们填了一个参数叫 notify_url，这是一个服务端的接口地址，微信在用户支付成功后，会回调这个地址，告知我们支付结果。 详情看文档 在这一步还是需要做多点校验的，免得被人有机可乘。 校验支付是否成功，不成功直接返回”FAIL” 校验签名和appid 校验订单是否完成(幂等校验，防止微信多次回调导致多次订单写入) 订单金额校验 一通校验完事之后就可以做业务相关的事了。记得所有操作结束后返回”SUCCESS”，不然微信会不断发起回调。 总结 流程图描述的很清楚，要仔细阅读流程图。 调用完下单接口后要进行二次签名，签名的参数要看前端验签用哪些参数，即使是同一个参数，字段名也会跟第一次加签不一样。 前端支付完成之后微信会有一个回调，我们需要做以下几点校验： 做幂等处理（因为同样的通知微信可能发送多次）。 校验签名，校验APPID。 校验订单金额。 订单状态分为 0-未支付 1-支付完成 2-支付失败： 用户触发支付组件然后关闭或者杀掉进程微信不会给到后台任何回复，始终处于 0-未支付，所以这个状态也是一个支付失败状态。 支付失败比较少见（到现在没有遇到过），比如签名错误（发生在调试阶段）。 微信回执表尽量详细的记录微信传回的所有必有参数，以备出问题时排查，可以直接丢到mongodb里。","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://yoursite.com/tags/wechat/"}]},{"title":"微信网页授权","slug":"微信网页授权","date":"2018-11-19T06:13:36.000Z","updated":"2018-11-19T06:13:36.000Z","comments":true,"path":"2018/11/19/微信网页授权/","link":"","permalink":"http://yoursite.com/2018/11/19/微信网页授权/","excerpt":"背景用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 配置 在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头； 授权回调域名配置规范为全域名，比如需要网页授权的域名为：www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html 、 http://www.qq.com/login.html 都可以进行OAuth2.0鉴权。但http://pay.qq.com 、 http://music.qq.com 、 http://qq.com无法进行OAuth2.0鉴权","text":"背景用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。 配置 在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头； 授权回调域名配置规范为全域名，比如需要网页授权的域名为：www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html 、 http://www.qq.com/login.html 都可以进行OAuth2.0鉴权。但http://pay.qq.com 、 http://music.qq.com 、 http://qq.com无法进行OAuth2.0鉴权 两种授权方式微信提供了两种授权方式来应对不同的使用场景。通过网页授权作用域 scope 参数控制。 静默授权 静默授权：用户进入页面后自动授权并跳转回页面，这种授权对用户无感知。通过这种授权我们只能获取到用户的 openid，无法获得用户的其他信息。 使用场景：只需要标识该用户，而不需要收集其他信息的场景都可以使用。比如投票、点赞等场景。 scope: snsapi_base 主动授权 主动授权：用户进入页面后会有授权弹窗，需要手动同意。该方试用来获取用户的基本信息 注意：对于已关注公众号的用户，用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope: snsapi_userinfo，也是静默授权，用户无感知。 scope: snsapi_userinfo 具体流程 用户进入页面，获取 code 通过 code 换取网页授权 access_token 和 openid，静默授权到这步结束 通过 access_token 获取用户信息 获取CODE引导用户跳传至该链接 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE 用户同意授权或静默授权后将跳转至 redirect_url?code=CODE&amp;state=STATE 这个地址并带上生成的 code。 code 作为换取access_token的票据，只能使用一次，5分钟未使用自动过期。 参数说明 通过 code 换取网页授权 access_token注意，这里的 access_token 和 调用公众平台API所需的基础 access_token不是一个东东，只是名字一样而已。 这一步是在服务端完成的，需要公众号的 secret，access_token 也不可以传给客户端。 请求接口 https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 返回 1234567&#123; &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;, &quot;expires_in&quot;:7200, &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;, &quot;openid&quot;:&quot;OPENID&quot;, &quot;scope&quot;:&quot;SCOPE&quot; &#125; 拉取用户信息（需scope为snsapi_userinfo）当网页授权作用域为 snsapi_userinfo时，开发者通过 access_token 和 openid 获取用户信息。 请求接口 https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 返回 1234567891011&#123; \"openid\": \"OPENID\", \"nickname\": \"NICKNAME\", \"sex\": \"1\", \"province\": \"PROVINCE\" \"city\": \"CITY\", \"country\": \"COUNTRY\", \"headimgurl\": \"http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46\", \"privilege\": [ \"PRIVILEGE1\" \"PRIVILEGE2\" ], \"unionid\": \"o6_bmasdasdsad6_2sgVt7hMZOPfL\"&#125; 参考资料微信网页授权官方文档","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://yoursite.com/tags/wechat/"}]},{"title":"小程序登录及用户信息和手机号的获取","slug":"小程序登录及用户信息和手机号的获取","date":"2018-11-16T06:28:58.000Z","updated":"2018-11-16T06:28:58.000Z","comments":true,"path":"2018/11/16/小程序登录及用户信息和手机号的获取/","link":"","permalink":"http://yoursite.com/2018/11/16/小程序登录及用户信息和手机号的获取/","excerpt":"登录流程 小程序通过 wx.login 获取 code(用户登录凭证，有效期五分钟，使用一次后实效) 服务端拿到 code，调用 code2Session，获取用户的 openid (用户在当前应用的唯一标识)、unionid (用户在开发平台的唯一标识) session_key (会话秘钥是对用户数据进行 加密签名 的秘钥，在获取用户信息时会用到) 等信息。为了安全，服务器不应该把会话秘钥下发到小程序，也不应该对外提供这个秘钥 通过 unionid openid 自定义服务端登录态","text":"登录流程 小程序通过 wx.login 获取 code(用户登录凭证，有效期五分钟，使用一次后实效) 服务端拿到 code，调用 code2Session，获取用户的 openid (用户在当前应用的唯一标识)、unionid (用户在开发平台的唯一标识) session_key (会话秘钥是对用户数据进行 加密签名 的秘钥，在获取用户信息时会用到) 等信息。为了安全，服务器不应该把会话秘钥下发到小程序，也不应该对外提供这个秘钥 通过 unionid openid 自定义服务端登录态 获取用户信息 用户授权后，小程序通过 wx.getUserInfo 获取用户信息，敏感信息被加密 把加密信息传给服务端，使用在登录时获取的 session_key 解密数据，解密方法可以看微信的 开放数据校验与解密文档 获取手机号需要用户主动触发才能发起获取手机号接口，所以该功能不由 API 来调用，需用 &lt;button&gt; 组件的点击来触发。获取手机号文档。 小程序通过 &lt;button&gt; 组件触发 getPhoneNumber 事件，获得加密后的信息 把加密信息传给服务端，使用在登录时获取的 session_key 解密数据，获得用户绑定的手机号 参考文档小程序开发文档","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://yoursite.com/tags/wechat/"}]},{"title":"Node.js 获取微信JS-SDK CONFIG","slug":"Node-js-获取微信JS-SDK-CONFIG","date":"2018-11-07T10:44:57.000Z","updated":"2018-11-07T10:44:57.000Z","comments":true,"path":"2018/11/07/Node-js-获取微信JS-SDK-CONFIG/","link":"","permalink":"http://yoursite.com/2018/11/07/Node-js-获取微信JS-SDK-CONFIG/","excerpt":"背景前端在调用微信提供的分享、拍照、扫一扫等功能时需要到后台获取配置，主要是签名(signature)。Node 开发可以用朴灵大佬的SDK——co-wechat-api。 配置到微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。前提是该域名的项目目录下有微信提供的校验文件。如果需要本地调试或者测试环境调试，可以把IP白名单也顺便配置一下。","text":"背景前端在调用微信提供的分享、拍照、扫一扫等功能时需要到后台获取配置，主要是签名(signature)。Node 开发可以用朴灵大佬的SDK——co-wechat-api。 配置到微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。前提是该域名的项目目录下有微信提供的校验文件。如果需要本地调试或者测试环境调试，可以把IP白名单也顺便配置一下。 开发实例化 WechatAPI 对象 1234567891011const WECHAT_API = new WechatAPI( appid, secret, get_access_token, // function save_access_token, // function 缓存 access_token);WECHAT_API.registerTicketHandle( get_js_api_ticket, // function save_js_api_ticket, // function 缓存 jsapi_ticket); 注意：jsapi_ticket 是公众号用于调用微信JS接口的临时票据。正常情况下，jsapi_ticket 的有效期为7200秒，通过 access_token 来获取。由于获取 jsapi_ticket 的api调用次数非常有限，频繁刷新 jsapi_ticket 会导致api调用受限，影响自身业务，开发者必须在自己的服务全局缓存 jsapi_ticket。同样的，access_token 有效期也是7200秒，同样需要全局缓存。 缓存的函数就是简单的 JSON.stringify 后存入 redis 或其他数据库。 调用123456const params = &#123; debug: false, jsApiList: [], // 需要获取的能力，由前端传入 url: '', // 申请能力并且在后台配置过的域名&#125;;ctx.body = await WECHAT_API.getJsConfig(params); 接入多个微信公众号待我重构归来。。。。。。","categories":[],"tags":[{"name":"wechat","slug":"wechat","permalink":"http://yoursite.com/tags/wechat/"},{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"代码顺序的重要性","slug":"代码顺序的重要性","date":"2018-11-07T10:43:57.000Z","updated":"2018-11-07T10:43:57.000Z","comments":true,"path":"2018/11/07/代码顺序的重要性/","link":"","permalink":"http://yoursite.com/2018/11/07/代码顺序的重要性/","excerpt":"背景在修改前辈留下来的代码时踩到一个坑。简单讲一下代码做了什么事：在 try/catch 里实例化多个类，并调用类的方法为其赋值，catch 到错误也不会中断，而是通过打日志的形式收集报错信息。 我需要在里面新实例化一个类，有样学样，上来就是一顿copy改，可是新增的类的某个属性总是不对，排查了半天才发现一个坑。","text":"背景在修改前辈留下来的代码时踩到一个坑。简单讲一下代码做了什么事：在 try/catch 里实例化多个类，并调用类的方法为其赋值，catch 到错误也不会中断，而是通过打日志的形式收集报错信息。 我需要在里面新实例化一个类，有样学样，上来就是一顿copy改，可是新增的类的某个属性总是不对，排查了半天才发现一个坑。 错误模拟12345678910111213141516171819202122232425262728class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; getX() &#123; return this.x &#125; setX(x) &#123; this.x = x &#125;&#125;let p, cattry &#123; p = new Point(1, 2) cat = new Cat('胖虎') // 这里实例化了一个不存在的类，用来模拟报错，实际情况比这个复杂 p.setX(66) // 这一行应该写在 `cat` 的前面，不然 `cat` 报错后直接中断下面语句的执行，导致这行语句没有执行&#125; catch (e) &#123; console.log(e)&#125;console.log(p.getX()) 执行结果，x 没有被赋值成66，抛出错误导致程序中断，赋值语句没有执行 正确的写法12345678910111213141516171819202122232425262728class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; getX() &#123; return this.x &#125; setX(x) &#123; this.x = x &#125;&#125;let p, cattry &#123; p = new Point(1, 2) p.setX(66) // 方法调用紧随实例后面，不受下面代码的影响 cat = new Cat('胖虎')&#125; catch (e) &#123; console.log(e)&#125;console.log(p.getX()) 执行结果，x 正确被赋值，错误也正常抛出 总结 如果 catch 了错误又不抛出，可以在调试的时候把错误抛出，方便发现问题。 代码结构顺序和整洁性很重要。 如果出现这种傻瓜式错误，是该考虑重构代码了。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"七牛视频防盗链处理","slug":"七牛视频防盗链处理","date":"2018-11-02T06:41:40.000Z","updated":"2018-11-02T06:41:40.000Z","comments":true,"path":"2018/11/02/七牛视频防盗链处理/","link":"","permalink":"http://yoursite.com/2018/11/02/七牛视频防盗链处理/","excerpt":"背景公司在做付费课程，视频教学为主，需要对视频链接作防盗链处理。 REFERERHTTP referer 是 header 上的一个属性。当浏览器向服务器发起请求时，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。 七牛在融合 CDN -&gt; 域名管理 -&gt; 高级配置里有一个域名防盗链选项。 配置好之后就可以限制链接只能从配置好的白名单域名进行访问，简单的防御了盗链。但是HTTP header 是可以被伪造的，经测试，直接用 postman 加个 Referer 就可以绕过了。","text":"背景公司在做付费课程，视频教学为主，需要对视频链接作防盗链处理。 REFERERHTTP referer 是 header 上的一个属性。当浏览器向服务器发起请求时，一般会带上Referer，告诉服务器我是从哪个页面链接过来的。 七牛在融合 CDN -&gt; 域名管理 -&gt; 高级配置里有一个域名防盗链选项。 配置好之后就可以限制链接只能从配置好的白名单域名进行访问，简单的防御了盗链。但是HTTP header 是可以被伪造的，经测试，直接用 postman 加个 Referer 就可以绕过了。 私有空间七牛云提供了私有空间，空间内的文件对象都要获得拥有者的授权才能进行访问，并且可以设置链接的有效时间，超过时长后自动失效（视频会有缓存，清空缓存之前视频仍然有效）。 如何创建私有空间的访问链接，下面是 Node.js SDK 的一段示例代码，其他语言可以去官网查看。 123456var mac = new qiniu.auth.digest.Mac(accessKey, secretKey);var config = new qiniu.conf.Config();var bucketManager = new qiniu.rs.BucketManager(mac, config);var privateBucketDomain = &apos;http://if-pri.qiniudn.com&apos;;var deadline = parseInt(Date.now() / 1000) + 3600; // 1小时过期var privateDownloadUrl = bucketManager.privateDownloadUrl(privateBucketDomain, key, deadline); 注意 测试域名不能用于私有空间。 自定义域名必须开启回源鉴权。 播放 hls 文件需要使用 pm3u8 服务。 详情可见这里：私有空间的注意事项。 PM3U8视频切片(七牛视频切片)后放在私有仓库时，获取单段视频的链接也需要带上token。七牛提供了 pm3u8服务 ，对 m3u8文件中的 ts 资源进行批量下载授权。通过将 ts 资源的 url 改写成私有 url，以临时获取访问权限。 有个需要注意的地方是，做签名处理时，要对整个链接做签名，比如 https://test.com/12354.m3u8?pm3u8/0。 123456var privateBucketDomain = &apos;http://if-pri.qiniudn.com&apos;;var deadline = parseInt(Date.now() / 1000) + 3600; // 1小时过期var key = 12354.m3u8?pm3u8/0; // pm3u8 参数和 url 一起做签名var privateDownloadUrl = bucketManager.privateDownloadUrl(privateBucketDomain, key, deadline); 还有个需要注意的地方是，虽然官方文档有一句这种提示，但和七牛沟通后的结果是，pm3u8 服务也是支持 https 的。 总结使用 REFERER + 私有空间 已经可以解决盗链问题了，但是如果视频被下载仍然是个问题。需要对视频做加密处理，但是即使做了加密处理，也阻止不了录屏。完全杜绝视频泄露是很难的，或者我们可以采取其他方式加大盗用的成本，比如在视频里加上水印或者观看者ID，甚至让水印或者观看者ID在视频里四处游走（影响观看体验）。","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"qiniu","slug":"qiniu","permalink":"http://yoursite.com/tags/qiniu/"},{"name":"七牛","slug":"七牛","permalink":"http://yoursite.com/tags/七牛/"}]},{"title":"白夜行","slug":"白夜行","date":"2018-10-31T01:51:58.000Z","updated":"2018-10-31T01:51:58.000Z","comments":true,"path":"2018/10/31/白夜行/","link":"","permalink":"http://yoursite.com/2018/10/31/白夜行/","excerpt":"“我呢，”雪穗继续说，“从来就没有生活在太阳底下。” “我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来没有太阳，所以不害怕失去。” ——《白夜行》东野圭吾。 开头是一宗离奇的命案，调查以无任何结果告终。然后开始分别叙述两位主人公的生活。从十一岁到初中到高中到成人，时间跨度长达十九年。每一件事单独看都是一个精彩的故事，谁知道最后所有的事情都会串起来成为解答开头命案的线索。本来以为是两个互不相关的两个人，作者在分别叙述他们的故事，看起来毫无相关性。看到最后才知道两个人始终在一起，策划着每一个意外。","text":"“我呢，”雪穗继续说，“从来就没有生活在太阳底下。” “我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来没有太阳，所以不害怕失去。” ——《白夜行》东野圭吾。 开头是一宗离奇的命案，调查以无任何结果告终。然后开始分别叙述两位主人公的生活。从十一岁到初中到高中到成人，时间跨度长达十九年。每一件事单独看都是一个精彩的故事，谁知道最后所有的事情都会串起来成为解答开头命案的线索。本来以为是两个互不相关的两个人，作者在分别叙述他们的故事，看起来毫无相关性。看到最后才知道两个人始终在一起，策划着每一个意外。 大师就是大师，把这么多繁复的事情一一叙述，中间用一条几乎不可见的线串联起来，看到最后只能张大嘴巴惊讶，原来竟是这样。 本来以为唐泽雪穗是一步一步黑化，其实在她十一岁被母亲卖给一个个男人，她的灵魂就已经被夺走了。她也用同样的方法夺走了三个女孩的灵魂，同时又达到自己的目的。而桐原亮司是一直爱着她的，他总是在人们看不见的地方守护雪穗。书的结尾描写他装扮成圣诞老人在雪穗新开的店里，应该是书中第一次描写两人同时出现在同一个地点，也是最后一次。被警察发现后抱着必死的决心跳楼，怕跳楼可能死不了还用自己心爱的剪刀插在心脏。桐原亮司要杀一个人确实从未失手过，包括他自己。 看一遍没办法看清细节，更何况我是有空才看一二十分钟，前后文间隔时间有点长，有的情节容易忘掉。下次再看一定要捧着实体书，在一个有阳光的午后，一次性看完。不过再次看时已经知道了每个人物身份每个情节，应该没了第一次看时的惊讶和刺激了吧。那就等我把情节忘记得差不多的时候，再重新读一遍吧。","categories":[],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]},{"title":"《码农翻身》读书笔记","slug":"《码农翻身》读书笔记","date":"2018-10-28T12:14:14.000Z","updated":"2018-10-28T12:14:14.000Z","comments":true,"path":"2018/10/28/《码农翻身》读书笔记/","link":"","permalink":"http://yoursite.com/2018/10/28/《码农翻身》读书笔记/","excerpt":"花了一天时间翻完了《码农翻身》（跳过了Java部分）。生动有趣的书看起来就是舒服，竟有引人入胜、手不释卷的感觉，一不小心就翻完了。是一本很好的入门科普读物，开阔技术视野。 下面是书中的摘抄和笔记 线程我是一个线程 不知道什么时候会被挑中执行 在执行的过程中随时可能被打断，让出CPU 一旦出现硬盘、数据库这样耗时的操作，也得让出CPU 数据来了，也不一定马上执行，还得等着被CPU挑选 三次握手TCP/IP之大明内阁TCP/IP之蓟辽督师TCP/IP 之 大明王朝邮差 发送的信息被拆分成小包裹，编上序号，打乱顺序后发送，由服务端发送，客户端接收，接收后返回确认接收信息。如果一定时间内没有收到确认信息，则代表信息丢失（可能是发出的包裹丢失，也可能是返回的确认信息丢失），重新发送该包裹。全部接收完成后按照序号重新组装成完整信息。 HTTPS一个故事讲完https","text":"花了一天时间翻完了《码农翻身》（跳过了Java部分）。生动有趣的书看起来就是舒服，竟有引人入胜、手不释卷的感觉，一不小心就翻完了。是一本很好的入门科普读物，开阔技术视野。 下面是书中的摘抄和笔记 线程我是一个线程 不知道什么时候会被挑中执行 在执行的过程中随时可能被打断，让出CPU 一旦出现硬盘、数据库这样耗时的操作，也得让出CPU 数据来了，也不一定马上执行，还得等着被CPU挑选 三次握手TCP/IP之大明内阁TCP/IP之蓟辽督师TCP/IP 之 大明王朝邮差 发送的信息被拆分成小包裹，编上序号，打乱顺序后发送，由服务端发送，客户端接收，接收后返回确认接收信息。如果一定时间内没有收到确认信息，则代表信息丢失（可能是发出的包裹丢失，也可能是返回的确认信息丢失），重新发送该包裹。全部接收完成后按照序号重新组装成完整信息。 HTTPS一个故事讲完https 这里面讲HTTPS讲的非常好，通俗易懂有趣。 bill的公钥及身份信息通过HTTPS传输给CA服务器，并生成数字证书。 验证完证书后，除了对称秘钥是用非对称加密传输，其他请求都使用对称加密通信。 如何确保CA公钥的安全ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。 这些顶层的ＣＡ证书一定得安全地放入操作系统／浏览器当中，否则世界大乱。 OTHER机房夜话 单点登录也讲得妙趣横生 从密码到token， 一个授权的故事 第三方授权，接入微信服务会经常用到。 张大胖的socket 端口号为了区分同一台服务器的不同进程。进程号是动态的，如果服务器端的进程重启了，进程号就变了。端口号就是从来标识服务器端的进程。 老司机的忠告 凡事必先骑虎上背 局部性原理（1）时间局部性：如果程序中的某条指令一旦执行，则不久之后该条指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。（2）空间局部性：是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。 抽象是计算机科学中极为重要的武器之一 要透彻地理解一门技术的本质 写漂亮的代码 书籍里的知识，体系更加完整，有深度——看书好过碎片阅读 不要游走在各大语言的边缘 坚持写作（输出）","categories":[],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]},{"title":"看见","slug":"看见","date":"2018-10-19T16:38:46.000Z","updated":"2018-10-19T16:38:46.000Z","comments":true,"path":"2018/10/20/看见/","link":"","permalink":"http://yoursite.com/2018/10/20/看见/","excerpt":"花了半个月断断续续看完了柴静的《看见》。这本书值得重新再看一次。 这次看这本书，用手机看，一目十行，有时候看着看着走神了，有时候动动手指就多翻了几页，或者在电梯里地铁里吃饭排队时匆匆看两眼。碎片时间让文章没了上下文，没了沉浸感。用手机看书是方便，随时随地，但不适合看一些有深度的书。 这本书是一个时代的记忆——非典，汶川地震，奥运。也记录了各式各样的人和群体——双城集体服毒的小学生，戒毒所里被卖去卖淫的女人，采访同性恋，不知道犯了什么罪就被关了二十八年的人，因家庭暴力杀死丈夫的女人，山西的环境污染，采访用高跟鞋踩死小猫拍成视频传到网上的女人，华南虎照片真假事件，福建涂岭拆迁户不同意搬迁，户主的儿子——一个刚复员回来的年轻人，二十三岁——被开发商砍死，农村征地问题，采访卢安克，药家鑫事件。","text":"花了半个月断断续续看完了柴静的《看见》。这本书值得重新再看一次。 这次看这本书，用手机看，一目十行，有时候看着看着走神了，有时候动动手指就多翻了几页，或者在电梯里地铁里吃饭排队时匆匆看两眼。碎片时间让文章没了上下文，没了沉浸感。用手机看书是方便，随时随地，但不适合看一些有深度的书。 这本书是一个时代的记忆——非典，汶川地震，奥运。也记录了各式各样的人和群体——双城集体服毒的小学生，戒毒所里被卖去卖淫的女人，采访同性恋，不知道犯了什么罪就被关了二十八年的人，因家庭暴力杀死丈夫的女人，山西的环境污染，采访用高跟鞋踩死小猫拍成视频传到网上的女人，华南虎照片真假事件，福建涂岭拆迁户不同意搬迁，户主的儿子——一个刚复员回来的年轻人，二十三岁——被开发商砍死，农村征地问题，采访卢安克，药家鑫事件。 还有她的恩师，陈虻。严苛，多批评很少夸奖，又恰好激发了潜力和斗志。能够遇到这样的引路人，我们只有羡慕的份。 这么多事情里，贯穿这本书的是：如何做一个合格的记者。书到结尾，没有答案，而是作者每个阶段对记者不同的理解。 是不是应该客观不带丝毫感情，要引导采访对象而不是咄咄逼问。要如何做一个记者，让形形色色的人愿意在你面前，在镜头面前吐露心声。如何知道得到的回答是受访者的本意，而非受记者有意引导。 往大了讲，如何辨别真假新闻——这是连特朗普都头疼的事。对于这个问题我就不敢乱说了，带着怀疑的态度看问题，有调查的新闻才是好新闻。 之前没有看过柴进的报道，特地去找了一集看一下。《双城的创伤》，小孩的内心世界往往比想象中的复杂，在心智还没完全成熟的时候，一些事对孩子来说可能是很大很难的事。柴静在采访结尾说：”双城事件调查到最后，我们发现，最大的迷，其实是孩子的内心世界，能不能打开它，可能是每个人都需要面对的问题。” 书摘 人们声称的最美好的岁月其实都是最痛苦的 无卷宗，无判决，无罪名，无期限。他被关了二十八年。 在中国，一个男人仍然可以打一个女人，用刀砍她的手，用酒瓶子扎她的眼睛，用枪抵住她的后背，强暴她的姐妹，殴打她的孩子。他甚至在众人面前这样子做，不会受到惩罚——只因为他是她的丈夫。 开始是不宣布对军队与政府不利的消息，后来发展为对军队和政府有利的消息要大力宣传。那些敢于坚持独立性、发出不同声音的报业成为受害者。 不再坐在教室里被动地接收别人灌输给我的东西了，而是主动地去了解。你们这些真正了解战争的人，请多告诉我们一些。 钱老师送这本书给我，我明白他当年让我读历史的原因：“新旧之间没有怨讼，唯有真与伪是大敌。” 宽容的基础是理解，你理解吗？ 你有自己认识事物的坐标体系吗？ 不要用道德的眼光看经济问题。 专制就是坚信自己是不会错的想法。 “你挺容忍的。”她说，“但你心里还是有委屈。”这话说得我一怔。委屈，这个词，好像心里有一只捏紧的小拳头。","categories":[],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]},{"title":"Node.js 使用 RSA 做加密","slug":"Node-js-使用-RSA-做加密","date":"2018-09-25T10:41:42.000Z","updated":"2018-09-25T10:41:42.000Z","comments":true,"path":"2018/09/25/Node-js-使用-RSA-做加密/","link":"","permalink":"http://yoursite.com/2018/09/25/Node-js-使用-RSA-做加密/","excerpt":"RSARSA加密算法是一种非对称加密算法。 假设 A 与 B 通信。A 和 B 都提供一个公开的公钥。A 把需要传递的信息，先用自己的私钥签名，再用 B 的公钥加密。B 接收到这串密文后，用自己的私钥解密，用 A 提供的公钥验签。 为什么要先签名后加密？如果你先加密后签名，非法用户通过获取的公钥就可以破解签名，破解之后就可以替换签名。 详细的原理可以参考以下文档：RSA算法原理（一）RSA算法原理（二） node-rsa在 node.js 中使用 rsa 算法，我们使用的是 node-rsa 这个包。 12345678910111213141516171819202122232425262728293031const NodeRSA = require('node-rsa');const a_public_key_data = '-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----';const a_private_key_data = '-----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY-----';const b_public_key_data = '-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----';const b_private_key_data = '-----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY-----';// 生成 A 的公私钥对象const a_public_key = new NodeRSA(a_public_key_data);const a_private_key = new NodeRSA(a_private_key_data);// 生成 B 的公私钥对象const a_public_key = new NodeRSA(a_public_key_data);const a_private_key = new NodeRSA(a_private_key_data);const text = 'Hello RSA!';// 加签并加密const sign = a_private_key.sign(text, 'base64', 'utf8');console.log('A 私钥加签:', sign);const encrypted = a_public_key.encrypt(sign, 'base64');console.log('B 公钥加密:', encrypted);// 解密并验签const decrypted = a_public_key.decrypt(encrypted, 'utf8');console.log('B 私钥解密:', decrypted);const verify = a_public_key.verify(text, decrypted, 'utf8', 'base64');console.log('A 公钥验签:', verify); serialize","text":"RSARSA加密算法是一种非对称加密算法。 假设 A 与 B 通信。A 和 B 都提供一个公开的公钥。A 把需要传递的信息，先用自己的私钥签名，再用 B 的公钥加密。B 接收到这串密文后，用自己的私钥解密，用 A 提供的公钥验签。 为什么要先签名后加密？如果你先加密后签名，非法用户通过获取的公钥就可以破解签名，破解之后就可以替换签名。 详细的原理可以参考以下文档：RSA算法原理（一）RSA算法原理（二） node-rsa在 node.js 中使用 rsa 算法，我们使用的是 node-rsa 这个包。 12345678910111213141516171819202122232425262728293031const NodeRSA = require('node-rsa');const a_public_key_data = '-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----';const a_private_key_data = '-----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY-----';const b_public_key_data = '-----BEGIN PUBLIC KEY----- ... -----END PUBLIC KEY-----';const b_private_key_data = '-----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY-----';// 生成 A 的公私钥对象const a_public_key = new NodeRSA(a_public_key_data);const a_private_key = new NodeRSA(a_private_key_data);// 生成 B 的公私钥对象const a_public_key = new NodeRSA(a_public_key_data);const a_private_key = new NodeRSA(a_private_key_data);const text = 'Hello RSA!';// 加签并加密const sign = a_private_key.sign(text, 'base64', 'utf8');console.log('A 私钥加签:', sign);const encrypted = a_public_key.encrypt(sign, 'base64');console.log('B 公钥加密:', encrypted);// 解密并验签const decrypted = a_public_key.decrypt(encrypted, 'utf8');console.log('B 私钥解密:', decrypted);const verify = a_public_key.verify(text, decrypted, 'utf8', 'base64');console.log('A 公钥验签:', verify); serialize 接口传递的一般是复杂的对象，所以我们需要把对象按一定的顺序排列并序列化成字符串再进行签名加密的操作 123456789const serialize = (obj) =&gt; &#123; const str = []; Object.keys(obj).sort().forEach((key) =&gt; &#123; if (obj.hasOwnProperty(key)) &#123; str.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key])); &#125; &#125;); return str.join('&amp;');&#125;; 注意RSA 算法有一定的计算量，加上 Node 不适合做计算密集型的操作。当接口被频繁调用可能会占用主线程，阻塞其他接口，使用了 RSA 的接口并发量会下降十倍左右。如非必要，谨慎在 Node 里使用 RSA。","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"rsa","slug":"rsa","permalink":"http://yoursite.com/tags/rsa/"}]},{"title":"用node.js写一个jenkins发版脚本","slug":"用node-js写一个jenkins发版脚本","date":"2018-09-25T10:41:05.000Z","updated":"2018-09-25T10:41:05.000Z","comments":true,"path":"2018/09/25/用node-js写一个jenkins发版脚本/","link":"","permalink":"http://yoursite.com/2018/09/25/用node-js写一个jenkins发版脚本/","excerpt":"背景每次到网页里手动发版有点烦，写个脚本来提高开发效率。 CFG在 jenkins 设置里获取 API TOKEN。把 host 和账号密码拼接起来就可以通过鉴权。 1234567const token = &#123; user: '', password: '',&#125;const host = 'jenkins.xxx.cn';const basicUrl = `http://$&#123;token.user&#125;:$&#123;token.password&#125;@$&#123;host&#125;`; BUILD","text":"背景每次到网页里手动发版有点烦，写个脚本来提高开发效率。 CFG在 jenkins 设置里获取 API TOKEN。把 host 和账号密码拼接起来就可以通过鉴权。 1234567const token = &#123; user: '', password: '',&#125;const host = 'jenkins.xxx.cn';const basicUrl = `http://$&#123;token.user&#125;:$&#123;token.password&#125;@$&#123;host&#125;`; BUILD 调用 jenkins 提供的 jenkins.job.build() 方法发版。 1234567891011121314151617// crumbIssuer 默认false, true 启用CSRF保护支持const jenkins = require('jenkins')(&#123; baseUrl, crumbIssuer: true &#125;);const job_name = ''; // 想要发版的job的名字jenkins.job.build( &#123; name: job_name, parameters: &#123; name: 'value', // 填写一些参数信息 &#125; &#125;, function(err, data) &#123; if (err) throw err; console.log('queue item number', data);&#125;); 查看发版状态执行 build 之后我们想要查看当前 build 的状态，只成功、失败还是进行中。 jenkins.job.get() 获取当前 job 的信息。data.lastBuild.number 可以拿到最后一个 build 的 number，最后一个 build 也就是我们刚刚触发的 build。jenkins.build.get() 获取当前 build 的信息。data.result 获取当前 build 的结果 1234567891011jenkins.job.get(job_name, (err, data) =&gt; &#123; if (err) throw err; const lastBuildNumber = data.lastBuild.number; console.log('last build number', lastBuildNumber); jenkins.build.get(job_name, lastBuildNumber, (err, data) =&gt; &#123; if (err) throw err; console.log('last build result', data.result); &#125;)&#125;); 资料jenkins","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/tags/jenkins/"}]},{"title":"七牛视频切片方案","slug":"七牛视频切片方案","date":"2018-08-07T14:23:28.000Z","updated":"2018-08-07T14:23:28.000Z","comments":true,"path":"2018/08/07/七牛视频切片方案/","link":"","permalink":"http://yoursite.com/2018/08/07/七牛视频切片方案/","excerpt":"使用七牛 sdk 上传视频并做分片操作。 step1 生成 token123456789101112131415161718192021222324const qiniu = require(\"qiniu\");var accessKey = proc.env.QINIU_ACCESS_KEY;var secretKey = proc.env.QINIU_SECRET_KEY;var mac = new qiniu.auth.digest.Mac(accessKey, secretKey);var bucket = proc.env.QINIU_TEST_BUCKET; // 对象存储空间//带数据处理的凭证var origin_filename = \"avthumb_test_target.mp4\"; // 源文件名var save_as_filename = `$&#123;origin_filename&#125;.m3n8`; // 分片后的文件名var saveMp4Entry = qiniu.util.urlsafeBase64Encode(`$&#123;bucket&#125;:$&#123;save_as_filename&#125;`);var avthumbMp4Fop = \"avthumb/m3u8/noDomain/1/segtime/15/vb/440k|saveas/\" + saveMp4Entry;var options = &#123; scope: bucket, expires: 3600, // 凭证有效时间 persistentOps: avthumbMp4Fop, // 视频上传后触发预转持久化，切片处理 persistentPipeline: \"video-pipe\", // 多媒体处理队列 persistentNotifyUrl: \"http://api.example.com/qiniu/pfop/notify\", // 回调通知地址&#125;var putPolicy = new qiniu.rs.PutPolicy(options);console.log(putPolicy.uploadToken(mac)); 生成不同作用的凭证可以查看官方提供的示例nodejs-sdk example。 以上代码为生成上传视频并进行切片处理的凭证。上传相关的文档查看七牛上传策略。 切片动作是由persistentOps参数触发并启动一个异步任务， persistentOps 详解","text":"使用七牛 sdk 上传视频并做分片操作。 step1 生成 token123456789101112131415161718192021222324const qiniu = require(\"qiniu\");var accessKey = proc.env.QINIU_ACCESS_KEY;var secretKey = proc.env.QINIU_SECRET_KEY;var mac = new qiniu.auth.digest.Mac(accessKey, secretKey);var bucket = proc.env.QINIU_TEST_BUCKET; // 对象存储空间//带数据处理的凭证var origin_filename = \"avthumb_test_target.mp4\"; // 源文件名var save_as_filename = `$&#123;origin_filename&#125;.m3n8`; // 分片后的文件名var saveMp4Entry = qiniu.util.urlsafeBase64Encode(`$&#123;bucket&#125;:$&#123;save_as_filename&#125;`);var avthumbMp4Fop = \"avthumb/m3u8/noDomain/1/segtime/15/vb/440k|saveas/\" + saveMp4Entry;var options = &#123; scope: bucket, expires: 3600, // 凭证有效时间 persistentOps: avthumbMp4Fop, // 视频上传后触发预转持久化，切片处理 persistentPipeline: \"video-pipe\", // 多媒体处理队列 persistentNotifyUrl: \"http://api.example.com/qiniu/pfop/notify\", // 回调通知地址&#125;var putPolicy = new qiniu.rs.PutPolicy(options);console.log(putPolicy.uploadToken(mac)); 生成不同作用的凭证可以查看官方提供的示例nodejs-sdk example。 以上代码为生成上传视频并进行切片处理的凭证。上传相关的文档查看七牛上传策略。 切片动作是由persistentOps参数触发并启动一个异步任务， persistentOps 详解 persistentOps 字段用于指定预转数据处理命令和保存处理结果的存储空间与资源名。为此字段指定非空值，则在成功上传一个文件后，会启动一个异步数据处理任务。persistentId 字段，唯一标识此任务。当 returnBody 中指定了 persistentId 魔法变量时，客户端收到的响应内容 returnBody 中会有 persistentId；当没有指定 returnBody 时，默认也会返回 persistentId。 使用默认的存储空间和资源名* 当只指定了数据处理命令时，服务端会选择上传文件的 Bucket 作为数据处理结果的存储空间，Key 由七牛服务器自动生成。 使用指定的存储空间和资源名 在数据处理命令后用管道符|拼接saveas/&lt;encodedEntryURI&gt;指令，指示七牛服务器使用EncodedEntryURI格式中指定的 Bucket 与 Key 来保存处理结果。如 avthumb/flv|saveas/cWJ1Y2tldDpxa2V5，是将上传的视频文件转码flv格式后存储为qbucket:qkey，其中cWJ1Y2tldDpxa2V5是qbucket:qkey的URL安全的Base64编码结果。以上方式可以同时作用于多个数据处理命令，用;分隔，如 avthumb/mp4|saveas/cWJ1Y2tldDpxa2V5;avthumb/flv|saveas/cWJ1Y2tldDpxa2V5Mg== 摘自七牛上传凭证 数据处理命令可以查看官方文档，比如视频切片接口。 step2 前端直传12345678910111213141516171819POST http://up.qiniu.com格式： form-data参数：key: 文件名，上文代码中的 `origin_filename`token: 上传tokenfile: 具体文件// 上传成功的响应体// 状态码 200&#123; \"hash\": \"luVJbz9RtE3Ha7c9XaDerE6rPyvP\", \"key\": \"prTEDwvJY18YBD_720_p1.mp4\", \"persistentId\": \"z0.5b56c9b938b9f324a573edb4\" // 可以使用persistentId，检测当前处理状态&#125;作者：youthcity链接：https://www.jianshu.com/p/f73b39ae02dc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 step3 轮询获取结果1234567891011121314151617181920212223242526GET api.qiniu.com/status/get/prefop?id=$&#123;persistentId&#125;&#123; \"code\": 0, // 状态码0成功，1等待处理，2正在处理，3处理失败，4通知提交失败。 \"desc\": \"The fop was completed successfully\", \"id\": \"z0.5b56c9b938b9f324a573edb4\", \"inputBucket\": \"ocean\", \"inputKey\": \"prTEDwvJY18YBD_720_p1.mp4\", \"items\": [ &#123; \"cmd\": \"avthumb/m3u8/noDomain/1/segtime/15/vb/440k|saveas/b2NlYW46aGxzX3ByVEVEd3ZKWTE4WUJEXzcyMF9wMS5tM3U4\", \"code\": 0, \"desc\": \"The fop was completed successfully\", \"hash\": \"FraV6PX6Xp7mYYgAnY0sniTK-pPt\", \"key\": \"hls_prTEDwvJY18YBD_720_p1.m3u8\", \"returnOld\": 0 &#125; ], \"pipeline\": \"1381326751.k12_video\", \"reqid\": \"FQIAAKAxpZfFOkQV\"&#125;作者：youthcity链接：https://www.jianshu.com/p/f73b39ae02dc來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 参考资料七牛上传凭证 七牛上传策略 视频切片接口 七牛上传开发（三）使用NodeJS生成带数据处理的凭证 nodejs-sdk example","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"qiniu","slug":"qiniu","permalink":"http://yoursite.com/tags/qiniu/"},{"name":"七牛","slug":"七牛","permalink":"http://yoursite.com/tags/七牛/"}]},{"title":"Sequelize 基本操作","slug":"Sequelize-基本操作","date":"2018-01-10T11:11:31.000Z","updated":"2018-01-10T11:11:31.000Z","comments":true,"path":"2018/01/10/Sequelize-基本操作/","link":"","permalink":"http://yoursite.com/2018/01/10/Sequelize-基本操作/","excerpt":"sequelize 基本操作Sequelize 是 Node 的一个 ORM(Object-Relational Mapping) 框架，用来方便数据库操作。 配置 sequelize 以 mysql 为例 首先我们要引入npm包，sequelize 依赖 mysql2 作为底层驱动，暴露出自己的 API 让我们调用，在转成 mysql 语句进行执行。 12\"mysql2\": \"^1.5.1\",\"sequelize\": \"^4.28.6\" 12345678910111213141516171819202122232425262728293031323334const Sequelize = require('sequelize')// 连接数据库const sequelize = new Sequelize('database', 'username', 'password', &#123; host: sqlconf.host, dialect: 'mysql', // 这里可以改成任意一种关系型数据库 pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000, &#125;,&#125;)// 测试连接是否成功sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.') &#125;) .catch(err =&gt; &#123; console.log('Unable to connect to the database', err) &#125;)// 根据 model自动创建表sequelize .sync() .then(() =&gt; &#123; console.log('init db ok') &#125;) .catch(err =&gt; &#123; console.log('init db error', err) &#125;) 我们可以调用sync()根据 model自动在数据库中创建表，也可以不调用，自己手动创。如果使用了 Sequelize 的 Associations，这必须通过 sync() 生成表结构。 创建 model创建模型，告诉 Sequelize 如何映射数据库表","text":"sequelize 基本操作Sequelize 是 Node 的一个 ORM(Object-Relational Mapping) 框架，用来方便数据库操作。 配置 sequelize 以 mysql 为例 首先我们要引入npm包，sequelize 依赖 mysql2 作为底层驱动，暴露出自己的 API 让我们调用，在转成 mysql 语句进行执行。 12\"mysql2\": \"^1.5.1\",\"sequelize\": \"^4.28.6\" 12345678910111213141516171819202122232425262728293031323334const Sequelize = require('sequelize')// 连接数据库const sequelize = new Sequelize('database', 'username', 'password', &#123; host: sqlconf.host, dialect: 'mysql', // 这里可以改成任意一种关系型数据库 pool: &#123; max: 5, min: 0, acquire: 30000, idle: 10000, &#125;,&#125;)// 测试连接是否成功sequelize .authenticate() .then(() =&gt; &#123; console.log('Connection has been established successfully.') &#125;) .catch(err =&gt; &#123; console.log('Unable to connect to the database', err) &#125;)// 根据 model自动创建表sequelize .sync() .then(() =&gt; &#123; console.log('init db ok') &#125;) .catch(err =&gt; &#123; console.log('init db error', err) &#125;) 我们可以调用sync()根据 model自动在数据库中创建表，也可以不调用，自己手动创。如果使用了 Sequelize 的 Associations，这必须通过 sync() 生成表结构。 创建 model创建模型，告诉 Sequelize 如何映射数据库表 12345678910111213const UserModel = sequelize.define('user', &#123; id: &#123; type: Sequelize.INTEGER(11), primaryKey: true, // 主键 autoIncrement: true, // 自动递增 &#125;, username: Sequelize.STRING(100), password: Sequelize.STRING(100), createdAt: Sequelize.BIGINT, updatedAt: Sequelize.BIGINT,&#125;, &#123; timestamps: false&#125;) define() 方法的第一个参数为表名，对应的是 users 表。如果不设置 timestamps，Sequlize 会自动为我们添加创建时间和更新时间，我一般选择关闭，手动添加灵活性高些。 增删改查增12345678910(async () =&gt; &#123; const now = Date.now() const user = await UserModel.create(&#123; username: '小张', password: 'root', createAt: now, updateAt: now, &#125;) console.log('创建：' + JSON.stringify(user))&#125;)(); 查123456789101112131415161718192021222324252627282930313233(async () =&gt; &#123; // 查找所有 const allUser = await UserModel.findAll() // 按id查找 const oneUser = await UserModel.findById(id) // 按条件查询 const someUser = await UserModel.findAll(&#123; where: &#123; // 模糊查询 name: &#123; $like: '%小%', &#125;, // 精确查询 password: 'root', &#125; &#125;) // 分页查询 const size = 10 // 每页10条数据 const page = 1 // 页数 const pageUser = await UserModel.findAndCountAll(&#123; where: &#123; name: &#123; $like: '%小%', &#125;, &#125;, limit: size, offset: size * (page - 1), &#125;)&#125;)(); 改12345678(async () =&gt; &#123;// 方法一await UserModel.upert(data) // data 里面如果带有 id 则更新，不带则新建// 方法二const user = await UserModel.findById(id)user.update(data)&#125;)() 删12345678910111213(async () =&gt; &#123;// 方法一// 删除所有名字带’小‘的用户await UserModel.destroy(&#123; where: &#123; username: '小', &#125;,&#125;)// 方法二const user = await UserModel.findById(id)user.destroy()&#125;)() 关联表Sequelize 提供了一对一，一对多，多对多等关联表操作，我用的不多，这里只介绍 hasMany() 这一种，其他的可以看文档。 设置首先要在 model 中设置 12345678910111213141516171819const School = sequelize.define('school', &#123; id: &#123; type: Sequelize.INTEGER(11), primaryKey: true, autoIncrement: true, &#125;, username: Sequelize.STRING(100),&#125;)const Student = sequelize.define('student', &#123; id: &#123; type: Sequelize.INTEGER(11), primaryKey: true, autoIncrement: true, &#125;, username: Sequelize.STRING(100),&#125;)School.hasMany(Student, &#123;as: 'student', foreignKey: 'schoolId'&#125;) as 参数重新定义了目标model的名字。foreignKey 参数定义了在 t_student 表中关联 key 的名字。 关联查如果我们想查找一个学校和这个学校中所有的学生信息，可以这样找： 12345678(async () =&gt; &#123; const group = await School.findById(id, &#123; include: [&#123; model: Student, as: 'student', &#125;], &#125;)&#125;)() 如果我们设置了 as 就需要在 include 选项中设置同样的 as。 按条件查找 1234567891011(async () =&gt; &#123; const group = await School.findAll(&#123; where: &#123; name: 'someting', &#125;, include: [&#123; model: Student, as: 'student', &#125;], &#125;)&#125;)() 文档更多详细操作请参考官方文档","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"解决 iPhone 微信 H5 无法自动播放音乐问题","slug":"解决-iPhone-微信-H5-无法自动播放音乐问题","date":"2017-11-29T09:29:26.000Z","updated":"2017-11-29T09:29:26.000Z","comments":true,"path":"2017/11/29/解决-iPhone-微信-H5-无法自动播放音乐问题/","link":"","permalink":"http://yoursite.com/2017/11/29/解决-iPhone-微信-H5-无法自动播放音乐问题/","excerpt":"","text":"使用 wx sdk 在html导入sdk js文件。（如果网站是https导入的sdk也要使用https！）然后在 wx.ready 中设置 play 方法并复制给全局变量 fm，当需要使用的时候再调用 fm() 12345678910111213141516171819202122// 全局变量 fm2var fm2;wx.config(&#123; debug : false, // 这里为false appId : '', // 以下随意填写即可 timestamp : (new Date()).getTime(), nonceStr : '', signature : '', jsApiList : ['checkJsApi']&#125;);wx.ready(function() &#123; $('#music1').play(); // 第一段音乐页面加载后自动播放 $('#music2').load(); // 第二段音乐等待，触发 fm2 时播放 fm2 = function () &#123; music2.play(); &#125;;&#125;);fm2(); //调用之后即可播放","categories":[],"tags":[{"name":"frontend","slug":"frontend","permalink":"http://yoursite.com/tags/frontend/"}]},{"title":"promise 和 async 的用法","slug":"promise-和-async-的用法","date":"2017-10-27T01:56:34.000Z","updated":"2017-10-27T01:56:34.000Z","comments":true,"path":"2017/10/27/promise-和-async-的用法/","link":"","permalink":"http://yoursite.com/2017/10/27/promise-和-async-的用法/","excerpt":"promise12345678910111213141516171819202122232425262728293031323334353637383940// 先构造一个 promise 函数// resolve 和 reject 都是一个函数// resolve 在成功时调用// reject 在失败时调用function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; let tar = Math.random(0, 1) if (tar &gt; 0.5) &#123; console.log('suceess') setTimeout(function() &#123; resolve('resolve') &#125;, 1000) &#125; else &#123; console.log('fail') setTimeout(function() &#123; reject('reject') &#125;, 1000) &#125; &#125;)&#125;// then 和 catch 第一个参数为resolve状态时的回调，第二个参数为reject状态时的回调// catch 相当于 then(null, reject)promise().then( (resolve) =&gt; console.log('then', resolve)).catch( (reject) =&gt; console.log('catch', reject))// then 后面还可以接 then 一直链式调用// 第一个 then 接受的参数是 resolve 函数传过来的参数// 第二个 then 接受一个参数是第一个 then 返回的值promise().then( (resolve) =&gt; (resolve + 1) // 接受 resolve 返回 resolve + 1).then( (plusOne) =&gt; console.log(plusOne) // 接受 resolve +1 并打印).catch( (reject) =&gt; console.log('catch', reject))","text":"promise12345678910111213141516171819202122232425262728293031323334353637383940// 先构造一个 promise 函数// resolve 和 reject 都是一个函数// resolve 在成功时调用// reject 在失败时调用function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; let tar = Math.random(0, 1) if (tar &gt; 0.5) &#123; console.log('suceess') setTimeout(function() &#123; resolve('resolve') &#125;, 1000) &#125; else &#123; console.log('fail') setTimeout(function() &#123; reject('reject') &#125;, 1000) &#125; &#125;)&#125;// then 和 catch 第一个参数为resolve状态时的回调，第二个参数为reject状态时的回调// catch 相当于 then(null, reject)promise().then( (resolve) =&gt; console.log('then', resolve)).catch( (reject) =&gt; console.log('catch', reject))// then 后面还可以接 then 一直链式调用// 第一个 then 接受的参数是 resolve 函数传过来的参数// 第二个 then 接受一个参数是第一个 then 返回的值promise().then( (resolve) =&gt; (resolve + 1) // 接受 resolve 返回 resolve + 1).then( (plusOne) =&gt; console.log(plusOne) // 接受 resolve +1 并打印).catch( (reject) =&gt; console.log('catch', reject)) async1234567891011121314151617181920212223242526272829303132333435// 同样需要一个 promise 对象function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; let tar = Math.random(0, 1) if (tar &gt; 0.5) &#123; console.log('success') setTimeout(function() &#123; resolve('resolve') &#125;, 1000) &#125; else &#123; console.log('fail') setTimeout(function() &#123; reject('reject') &#125;, 1000) &#125; &#125;)&#125;// 只是调用的方法跟 then/catch 不一样// async 函数执行时，一旦遇到 await 就会先返回，等异步操作完成，再接着执行后面的操作async function async() &#123; const res = await promise() console.log(res) console.log('wait') return res&#125;// async 函数返回 promise 对象// 只有函数内的 await 语句全部执行完，或者遇到 return 或 抛出错误，才会发生状态改变// 如果发生错误或状态为 reject 则执行 catchasync().then( (res) =&gt; console.log(res)).catch( (e) =&gt; console.log(e))","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"阿里云云服务器的端口配置问题","slug":"阿里云云服务器的端口配置问题","date":"2017-05-23T06:26:28.000Z","updated":"2017-05-23T06:26:28.000Z","comments":true,"path":"2017/05/23/阿里云云服务器的端口配置问题/","link":"","permalink":"http://yoursite.com/2017/05/23/阿里云云服务器的端口配置问题/","excerpt":"心血来潮花了9块9（学生价）买了个阿里云。因为后端只会一点 Node，所以上来第一件事就是按照官方教程把部署 Node 项目这个教程撸了一遍。 问题描述官方教程代码1234567891011const http = require('http');const hostname = 'ECS公网IP地址'; // 这里把文字换成自己的\b公网IP地址const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 一段简单最简单的 Node http服务器，成功运行后可以在页面输出 Hello World。","text":"心血来潮花了9块9（学生价）买了个阿里云。因为后端只会一点 Node，所以上来第一件事就是按照官方教程把部署 Node 项目这个教程撸了一遍。 问题描述官方教程代码1234567891011const http = require('http');const hostname = 'ECS公网IP地址'; // 这里把文字换成自己的\b公网IP地址const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 一段简单最简单的 Node http服务器，成功运行后可以在页面输出 Hello World。 报错 报错了，因为之前写node只需要监听端口，没必要把IP地址也给写进去，所以我删了\bhostname，改成下面这样。 1234567891011const http = require('http');const hostname = 'ECS公网IP地址'; // 这里把文字换成自己的\b公网IP地址const port = 3000;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');&#125;);server.listen(port, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 运行成功，但是在外网用\b浏览器输入IP地址\b之后无法访问。 问题分析curl ip.cn 查询当前外网IP，没有问题，与阿里云提供的一致。 ping www.baidu.com 服务器可以访问外网 curl http://127.0.0.1:3000 正确输出 “Hello World”，说明代码的编写没有问题。 代码没问题，服务器网络没问题，ip地址没问题。我估计应该是防火墙把端口禁掉了。 关闭防火\b墙身为小菜鸟，第一时间想到的就是把服务器的防火墙关掉。我的服务器是 CentOS7.0 ，与6.0不一样，CentOS7.0默认使用 firewall 作为防火墙。 systemctl stop firewalld.service #停止firewall systemctl disable firewalld.service #禁止开机启动firewall firewall-cmd --state #查看防火墙状态，已经处于关闭状态 开Node服务器，浏览器访问还是失败。 好像没招了，问小伙伴，他们说可能是没有备案的原因。但是没备案的小伙伴说他用得好好的，而且我就买了一个月的服务器，\b再等半个月备案我也不需要用了。正打算放弃问客服，小伙伴说你装个Nginx试试，只要正确运行\bNginx而且服务器没问题直接访问IP地址就能出现Nginx首页了。 安装 NginxCentOS有两种方法安装Nginx，具体的自行谷歌吧。 安装完成，运行成功。 浏览器访问公网\bIP，无法访问。 从吃完中午饭13:00一直折腾到下午6:30左右，一动不动坐凳子上\b5个多小时了，不行了，休息吃完饭去。 解决既然Nginx正确运行，那只剩两个问题了，一个是没有备案，不过这个问题的可能性很小很小。还有一点就是虽然我CentOS上把防火墙关了，但云服务器上阿里云应该\b会有一些安全措施，导致一部分端口被禁，或者压根就没有把\b端口打开。 吃完饭，散完步，我就在云服务器\b控制台\b里一个一个的找，发现安全组里点击配置规则后有一个安全组规则，里面通过添加安全组规则可以\b开放需要用到的端口。默认只打开了两个端口。 总结这是一个简单的问题，不过需要一步步排除掉可能的原因。 如果身边有个后端或者运维的小伙伴在的话，应该可以很快意识到这个问题。独狼是走不远的，至少是走不快的。 其实在购买时就可以选取要开放的端口，第一次嘛，没有经验，都是直接默认选项。怪不得小伙伴说他服务器的配置都没有动过，应该是购买的时候就已经设置好的。 趁年轻，多踩坑。","categories":[],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"《图解HTTP》读书笔记","slug":"《图解HTTP》读书笔记","date":"2017-04-23T12:49:25.000Z","updated":"2017-04-23T12:49:25.000Z","comments":true,"path":"2017/04/23/《图解HTTP》读书笔记/","link":"","permalink":"http://yoursite.com/2017/04/23/《图解HTTP》读书笔记/","excerpt":"TCP/IP 协议族TCP/IP 协议族按层次分为以下4层：应用层、传输层、网络层和数据链路层。 应用层决定了向用户提供应用服务时通信的活动。DNS服务、HTTP协议处于该层。 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP协议处于该层。 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方的计算机，并把数据包传给对方。IP网际协议位于该层。 链路层用来处理链接网络的硬件部分。包括操作系统、硬件驱动等。","text":"TCP/IP 协议族TCP/IP 协议族按层次分为以下4层：应用层、传输层、网络层和数据链路层。 应用层决定了向用户提供应用服务时通信的活动。DNS服务、HTTP协议处于该层。 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP协议处于该层。 网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方的计算机，并把数据包传给对方。IP网际协议位于该层。 链路层用来处理链接网络的硬件部分。包括操作系统、硬件驱动等。 IP协议IP网际协议位于网络层。IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是IP地址和MAC地址。 IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会改变。 TCP协议TCP协议位于传输层，提供可靠的字节流服务。 所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。 三次握手（three-way handshaking）为了准确无误地将数据送达目标处，TCP协议采用了三次握手策略。 发送端发送一个带SYN标志的数据包给对方 –&gt; 接受端收到后传回一个带SYN/ACK标志的数据包以示传达确认信息 –&gt; 发送端再传回一个带ACK标志的数据包表示握手结束 DNS服务DNS服务位于应用层。提供域名到IP地址之间的解析服务。 整个服务的流程客户端请求一个网址 –&gt; DNS把域名解析为IP地址 –&gt; HTTP生成针对目标Web服务器的HTTP请求报文 –&gt; TCP将HTTP请求报文分割成报文段按序号传输 –&gt; IP协议负责搜索对方的地址边中转边传送 –&gt; TCP从对方那里接受报文段并重组成报文 –&gt; HTTP对请求的内容进行处理 –&gt; 请求的处理结果也按照这个流程返回客户端 HTTP 协议HTTP 方法 方法 作用 说明 GET 获取资源 POST 传输实体主体 一般用于提交需要存储的信息 HEAD 获取报文首部 和GET一样，只是不返回报文主体部分 DELETE 删除文件 OPTIONS 询问支持的方法 持久连接在HTTP/1.1中，所有的连接默认都是持久连接 HTTP 状态码 状态码 类别 2** 成功 3** 重定向 4** 客户端错误 5** 服务端错误","categories":[],"tags":[{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"一个 Vue + Node + MongoDB 博客系统","slug":"一个-Vue-Node-MongoDB-博客系统","date":"2017-04-22T11:45:10.000Z","updated":"2017-04-22T11:45:10.000Z","comments":true,"path":"2017/04/22/一个-Vue-Node-MongoDB-博客系统/","link":"","permalink":"http://yoursite.com/2017/04/22/一个-Vue-Node-MongoDB-博客系统/","excerpt":"源码耗时半载（半个月）的大项目终于完成了。这是一个博客系统，使用 Vue 做前端框架，Node + express 做后端，数据库使用的是 MongoDB。实现了用户注册、用户登录、博客管理（文章的修改和删除）、文章编辑（Markdown）、标签分类等功能。 很早之前就想写一个个人博客。学了 Vue 之后，把前端部分写出来，然后 Node 一直拖拖拉拉的学了很久，中间又跑去实习了一段时间，所以直到回学校之后才列了个计划把这个项目实现了。 翻出之前写的前端部分，好丑啊，干脆推掉重写吧。前端模仿的是 hexo 的经典主题 NexT ，本来是想把源码直接拿过来用的，后来发现还不如自己写来得快，就全部自己动手实现成 vue components。 实现的功能 文章的编辑，修改，删除 支持使用 Markdown 编辑与实时预览 支持代码高亮 给文章添加标签 支持用户注册登录 使用到的技术前端 Vue.js vue-cli vue-router vue-resource element-ui marked highlight.js 后端 Node.js Express Mongoose 基本思路前端使用 vue-router 操作路由，实现单页应用的效果。使用 vue-resource 从后台获取数据，数据的处理全部都在前端，所以后端要做的事情很简单——把前端打包好的数据存进数据库中和从数据库中取出数据。前后端使用统一的路由命名规则。","text":"源码耗时半载（半个月）的大项目终于完成了。这是一个博客系统，使用 Vue 做前端框架，Node + express 做后端，数据库使用的是 MongoDB。实现了用户注册、用户登录、博客管理（文章的修改和删除）、文章编辑（Markdown）、标签分类等功能。 很早之前就想写一个个人博客。学了 Vue 之后，把前端部分写出来，然后 Node 一直拖拖拉拉的学了很久，中间又跑去实习了一段时间，所以直到回学校之后才列了个计划把这个项目实现了。 翻出之前写的前端部分，好丑啊，干脆推掉重写吧。前端模仿的是 hexo 的经典主题 NexT ，本来是想把源码直接拿过来用的，后来发现还不如自己写来得快，就全部自己动手实现成 vue components。 实现的功能 文章的编辑，修改，删除 支持使用 Markdown 编辑与实时预览 支持代码高亮 给文章添加标签 支持用户注册登录 使用到的技术前端 Vue.js vue-cli vue-router vue-resource element-ui marked highlight.js 后端 Node.js Express Mongoose 基本思路前端使用 vue-router 操作路由，实现单页应用的效果。使用 vue-resource 从后台获取数据，数据的处理全部都在前端，所以后端要做的事情很简单——把前端打包好的数据存进数据库中和从数据库中取出数据。前后端使用统一的路由命名规则。 项目目录123456789101112131415161718192021| app.js 后端入口| index.html 入口页面| .babelrc babel配置| .gitignore git配置| package.json| webpack.config.js webpack配置||-dist vue打包生成的文件||-node_modules 模块||-server 后端 | check.js | db.js 数据库 __| router.js 路由||-src 前端 |-assets 静态资源 |-components 组件 | App.vue | main.js webpack 配置webpack 大部分是 vue-cli 自动生成的，添加了让前后端http请求都转到node的3000端口，而不是前端的8080端口的配置。 1234567891011devServer: &#123; historyApiFallback: true, noInfo: true, //让前后端http请求都转到node的3000端口，而不是前端的8080端口 proxy: &#123; '/': &#123; target: 'http://localhost:3000/' &#125; &#125; &#125; 这里涉及一个新手可能会不明白的问题（我之前就捣鼓了半天）。 开发的时候要先打开数据库 MongoDB ,使用命令 mongod。 然后打开后端服务器 node app，后端监听 3000 端口。 最后打开前端开发模式 npm run dev，前端启动了一个 webpack 服务器，监听 8080 端口用于热刷新。通过配置把前端的http请求转到 3000 端口。 前端部分命名视图所有页面都用到的元素可以写在 App.vue 上面，也可以写成公共组件。我在 App.vue 中使用了命名视图，因为 sidebar 这个组件有的页面需要有的不需要，不需要的时候就不用加载。 12345678910&lt;!--App.vue--&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;div class=\"black_line\"&gt;&lt;/div&gt; &lt;div id=\"main\"&gt; &lt;router-view name=\"sidebar\"&gt;&lt;/router-view&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; router路由的配置写在 main.js 中，分为前台展示和后台管理。后台管理统一以 ‘/admin’ 开头。注册页和登录页写在一起了，上面有两个按钮“注册”和“登录”（我好懒-_-）。 12345678910111213// main.jsconst router = new VueRouter(&#123; routes: [ &#123;path: '/', components: &#123;default: article, sidebar: sidebar&#125;&#125;, &#123;path: '/article', components: &#123;default: article, sidebar: sidebar&#125;&#125;, &#123;path: '/about', components: &#123;default: about, sidebar: sidebar&#125;&#125;, &#123;path: '/articleDetail/:id', components: &#123;default: articleDetail, sidebar: sidebar&#125;&#125;, &#123;path: '/admin/articleList', components: &#123;default: articleList, sidebar: sidebar&#125;&#125;, &#123;path: '/admin/articleEdit', component: articleEdit&#125;, &#123;path: '/admin/articleEdit/:id', component: articleEdit&#125;, &#123;path: '/admin/signin', component: signin&#125; ]&#125;) element UI使用了 element 用于消息提醒和标签分类。并不需要整个引入，而是使用按需引入。 123456789101112131415161718// main.js// 按需引用elementimport &#123; Button, Message, MessageBox, Notification, Popover, Tag, Input &#125; from 'element-ui'import 'element-ui/lib/theme-default/index.css'const components = [Button, Message, MessageBox, Notification, Popover, Tag, Input]components.forEach((item) =&gt; &#123; Vue.component(item.name, item)&#125;)const MsgBox = MessageBoxVue.prototype.$msgbox = MsgBoxVue.prototype.$alert = MsgBox.alertVue.prototype.$confirm = MsgBox.confirmVue.prototype.$prompt = MsgBox.promptVue.prototype.$message = MessageVue.prototype.$notify = Notification vue-resource用于向后端发起请求。打通前后端的关键。 123456// GET /someUrl this.$http.get('/someUrl').then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;); get 请求前端发起 get 请求，当请求成功被返回执行第一个回调函数，请求没有被成功返回则执行第二个回调函数。1234this.$http.get('/api/articleDetail/' + id).then( response =&gt; this.article = response.body, response =&gt; console.log(response)) 后端响应请求并返回结果12345678910// router.jsrouter.get('/api/articleDetail/:id', function (req, res) &#123; db.Article.findOne(&#123; _id: req.params.id &#125;, function (err, docs) &#123; if (err) &#123; console.error(err) return &#125; res.send(docs) &#125;)&#125;) post 请求前端发起 post 请求，当请求成功被返回执行第一个回调函数，请求没有被成功返回则执行第二个回调函数。12345678910111213141516171819202122// 新建文章// 即将被储存的数据 objlet obj = &#123; title: this.title, date: this.date, content: this.content, gist: this.gist, labels: this.labels&#125;this.$http.post('/api/admin/saveArticle', &#123; articleInformation: obj&#125;).then( response =&gt; &#123; self.$message(&#123; message: '发表文章成功', type: 'success' &#125;) // 保存成功后跳转至文章列表页 self.refreshArticleList() &#125;, response =&gt; console.log(response)) 后端存储数据并返回结果1234567891011// router.js// 文章保存router.post('/api/admin/saveArticle', function (req, res) &#123; new db.Article(req.body.articleInformation).save(function (err) &#123; if (err) &#123; res.status(500).send() return &#125; res.send() &#125;)&#125;) 后端部分后端使用 express 构建了一个简单的服务器，几乎只用于操作数据库。 app.js 位于项目根目录，使用 node app 运行服务器。 123456789101112131415161718192021222324252627282930313233343536373839const express = require('express')const fs = require('fs')const path = require('path')const bodyParse = require('body-parser')const session = require('express-session')const MongoStore = require('connect-mongo')(session)const router = require('./server/router')const app = express()const resolve = file =&gt; path.resolve(__dirname, file)app.use('/dist', express.static(resolve('./dist')))app.use(bodyParse.json())app.use(bodyParse.urlencoded(&#123; extended: true &#125;))app.use(router)// sessionapp.set('trust proxy', 1) // trust first proxyapp.use(session(&#123; secret: 'blog', resave: false, saveUninitialized: true, cookie: &#123; secure: true, maxAge: 2592000000 &#125;, store: new MongoStore(&#123; url: 'mongodb://localhost:27017/blog' &#125;)&#125;))app.get('*', function (req, res) &#123; let html = fs.readFileSync(resolve('./' + 'index.html'), 'utf-8') res.send(html)&#125;)app.listen(3000, function () &#123; console.log('访问地址为 localhost:3000')&#125;) 给自己挖了一个坑。因为登录之后需要保存用户状态，用来判断用户是否登录，如果登录则可以进入后台管理，如果没有登录则不能进入后台管理页面。之前写 node 的时候用的是 session 来保存，不过spa应用不同于前后端不分离的应用，我在前端对用户输入的账号密码进行了判断，如果成功则请求登录在后端保存 session。不过不知道出于什么原因，session 总是没办法赋值。因为我 node 学的也是半吊子，所以暂时放着，等我搞清楚了再来填坑。 收获 学一个新模块，新框架第一步就是阅读官方文档。 不要觉得读文档费时间，认真的读一遍官方文档比你瞎折腾来得有效率。 阅读与你项目相关的优秀项目的源码，学习别人如何组织代码。 自己的解决方案不一定是最优解，不过在找到最优解之前不妨自己先试试。 框架模块的使用都不难，套API的活每个人都能干，只是快与慢的差别。 尝试思考这个API是如何实现的。 了解了完整的web应用是如何运作的，包括服务器，数据库，前端是如何联系在一起的。","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"mongoDB基本操作","slug":"mongoDB基本操作","date":"2017-04-17T03:28:54.000Z","updated":"2017-04-17T03:28:54.000Z","comments":true,"path":"2017/04/17/mongoDB基本操作/","link":"","permalink":"http://yoursite.com/2017/04/17/mongoDB基本操作/","excerpt":"创建数据库use DATABASE_NAME 如果数据库不存在则创建，否则切换到指定数据库 db查看当前数据库名 show dbs 查看所有数据库 show tables 查看集合 删除数据库db.dropDatabase() 删除当前数据库 db.collection.drop() 删除集合，collection为集合名，例db.student.drop() 插入文档db.COLLECTION_NAME.insert(document)实例12345db.col.insert(&#123; title: 'MongoDB教程', tags: ['mongodb', 'database', 'nosql'], url: 'www.runoob.com'&#125;)","text":"创建数据库use DATABASE_NAME 如果数据库不存在则创建，否则切换到指定数据库 db查看当前数据库名 show dbs 查看所有数据库 show tables 查看集合 删除数据库db.dropDatabase() 删除当前数据库 db.collection.drop() 删除集合，collection为集合名，例db.student.drop() 插入文档db.COLLECTION_NAME.insert(document)实例12345db.col.insert(&#123; title: 'MongoDB教程', tags: ['mongodb', 'database', 'nosql'], url: 'www.runoob.com'&#125;) 我们也可以把数据定义为变量 1234567document = (&#123; // 记得这边有个括号 title: 'MongoDB教程', tags: ['mongodb', 'database', 'nosql'], url: 'www.runoob.com'&#125;)db.col.insert(document) 插入文档也可以使用 db.col.save(document) 命令，如果不指定 _id 字段save()方法类似于 insert()。如果指定 _id 字段，则会更新该 _id 的数据。 更新文档update()方法123456789db.collection.update( &lt;query&gt;, // 查询条件 &lt;update&gt;, //update的对象和一些更新的操作符 &#123; upsert: &lt;boolean&gt;, // 可选 multi: &lt;boolean&gt;, // 可选 writeConcern: &lt;document&gt; // 可选，抛出异常的级别 &#125;) 例子db.col.update({&#39;title&#39;:&#39;MongoDB 教程&#39;},{$set:{&#39;title&#39;:&#39;MongoDB&#39;}}) 以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置multi参数为true save()方法123456db.collection.save( &lt;document&gt;, // 传入文档用来替换之前的文档 &#123; writeConcern: &lt;document&gt; &#125;) 例子123456789101112db.col.save(&#123; &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;), // id唯一 &quot;title&quot; : &quot;MongoDB&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;Runoob&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 110&#125;) 删除文档1234567db.collection.remove( &lt;query&gt;, // 可选，删除的文档的条件 &#123; justOne:&lt;boolean&gt;, // 可选，如果为true或1，则只删除一个文档 writeConcern: &lt;document&gt; // 可选，抛出异常级别 &#125;) 例子db.col.remove({&#39;title&#39;:&#39;mongodb&#39;}) db.col.remove({}) 删除所有数据 查询文档db.col.find() 查看已插入的文档db.col.find().pretty() 输出好看的格式db.col.findOne() 只返回一个文档 条件操作符(&gt;) 大于 - $gt(&lt;) 小于 - $lt(&gt;=) 大于等于 - $gte(&lt;= ) 小于等于 - $ltedb.col.find({&quot;likes&quot; : {$gt : 100}}) 查找likes大于100的数据 AND条件传入多个键值然后逗号隔开db.col.find({key1: value1, key2: value2}).pretty() OR条件1234 [ &#123;key1: value1&#125;, &#123;key2: value2&#125; ]&#125;).pretty() $type操作符 类型 数字 Double 1 String 2 Object 3 Array 4 Binary data 5 Object id 7 Boolean 8 Date 9 Null 10 不全，完整表格访问这里 db.col.find({&#39;title&#39; :{$type: 2}}) 如果title为String则输出 limit and skipdb.col.find().limit(2) 只读取两条db.col.find().limit(1).skip(1) 跳过第一条，只显示第二条skip默认为0 sort()方法1升序，-1降序 db.col.find().sort({key: 1}) 例子db.col.find({}, {&#39;title&#39;: 1, _id: 0}).sort({&#39;likes&#39;: -1})","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"二叉树的递归算法","slug":"二叉树的递归算法","date":"2017-04-16T12:58:20.000Z","updated":"2017-04-16T12:58:20.000Z","comments":true,"path":"2017/04/16/二叉树的递归算法/","link":"","permalink":"http://yoursite.com/2017/04/16/二叉树的递归算法/","excerpt":"二叉树二叉树是一种特殊的数据结构，有一个根节点，根节点下面有一左一右两个子节点，每个子节点又有各自的子节点，层层深入成树状。 二叉树的遍历关于二叉树的遍历我只学习了递归遍历，非递归遍历比较复杂还是很理解。 递归遍历分为先序，中序和后序。用三个字母表示递归遍历可以很好理解： D: 访问根节点，L： 遍历根节点的左子树，R：遍历根节点的右子树。 先序遍历：DLR 中序遍历：LDR 后序遍历：LRD","text":"二叉树二叉树是一种特殊的数据结构，有一个根节点，根节点下面有一左一右两个子节点，每个子节点又有各自的子节点，层层深入成树状。 二叉树的遍历关于二叉树的遍历我只学习了递归遍历，非递归遍历比较复杂还是很理解。 递归遍历分为先序，中序和后序。用三个字母表示递归遍历可以很好理解： D: 访问根节点，L： 遍历根节点的左子树，R：遍历根节点的右子树。 先序遍历：DLR 中序遍历：LDR 后序遍历：LRD 先序遍历的递归算法1234567function preOrder(node) &#123; if (node) &#123; console.log(node.value); preOrder(node.left); preOrder(node.right); &#125;&#125; 中序遍历的递归算法1234567function inOrder(node) &#123; if (node) &#123; inOrder(node.left); console.log(node.value); inOrder(node.left); &#125;&#125; 后序遍历的递归算法1234567function postOrder(node) &#123; if (node) &#123; postOrder(node.left); postOrder(node.right); console.log(node.value); &#125;&#125; 更详细的二叉树算法可以查看这篇文章 定时问题遇到的一个难题是如何实现间隔一段时间（500ms）改变节点的颜色，这就需要用到setTimeout()这个方法。刚开始的想法是把定时函数写进递归函数里面，让每次递归都执行setTimeout()，但是这个方法行不通，会改变每个节点出现的顺序，而且函数执行结束的时间小于定时时间，导致想要达到的效果一瞬间全部执行完毕，而不是按规定的时间一个一个出现，这个理解可能有点错误，但是没办法达到想要的效果，所以放弃。 我的方法是把遍历出来的值放进数组里，然后再用数组完成想要做的各种操作。 12345678910111213function preOrder(node) &#123; if (node) &#123; preOrder(node.left); preOrder(node.right); preList.push(node.value); &#125;&#125;for (let i = 0; i &lt; preList.length; i++) &#123; setTimeout(function() &#123; console.log(preList[i]); // 这样就可以按顺序每隔一段时间打印出一个数字 &#125;, 500 * i);&#125;","categories":[],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/tags/algorithms/"}]},{"title":"《Algorithms Unlocked》读书笔记3——计数排序","slug":"《Algorithms-Unlocked》读书笔记3——计数排序","date":"2017-04-16T12:55:57.000Z","updated":"2017-04-16T12:55:57.000Z","comments":true,"path":"2017/04/16/《Algorithms-Unlocked》读书笔记3——计数排序/","link":"","permalink":"http://yoursite.com/2017/04/16/《Algorithms-Unlocked》读书笔记3——计数排序/","excerpt":"《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础，算是啃CLRS前的开胃菜和辅助教材。如果CLRS的厚度让人望而生畏，这本200多页的小读本刚好合适带你入门。 书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。 超越下界之前的四个排序算法——选择排序、插入排序、归并排序、快速排序都是依赖于对排序关键字进行的比较。他们的决策依据都是“如果这个元素的排序关键字比另一个元素的排序关键字小，那么就进行相应操作，否则，进行其他操作或者什么也不做。”假如我们还是依赖这一规则，无论是简单或复杂的算法或者还没被发现的算法都无法突破这一下界（最坏情况下所需要的最小时间）。所以我们需要更改游戏规则，不让算法利用比较来进行排序。 计数排序假设我们有一个数组，该数组内的元素都是 0~m-1 范围内的整数。例如 let array = [4, 1, 5, 0, 1, 6, 5, 1, 5, 3] 。如果我们可以知道排序关键字为 5 的元素有三个，并且刚好有 6 个元素的排序关键字小于 5，那么三个 5 应该位于位置6、7、8上。 首先我们要计算出有多少个元素的排序关键字等于某个值。比如有 3 个元素的排序关键字等于 5。 123456789101112131415161718// m:定义了数组array中元素的取值范围 0~m-1function countKeysEqual(array, m) &#123; // 创建一个空数组，长度为m，给每个元素赋值0 // 为什么要有这一步，万一哪个值array里没有就会变成NaN let equal = []; for (let i = 0; i &lt; m; i++) &#123; equal[i] = 0; &#125;; for (let j = 0; j &lt; array.length; j++) &#123; // 把array中的元素作为equal数组的索引值 // 该索引值在equal中对应的值为该元素在array中出现的次数 let key = array[j]; equal[key] += 1; &#125; return equal;&#125;","text":"《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础，算是啃CLRS前的开胃菜和辅助教材。如果CLRS的厚度让人望而生畏，这本200多页的小读本刚好合适带你入门。 书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。 超越下界之前的四个排序算法——选择排序、插入排序、归并排序、快速排序都是依赖于对排序关键字进行的比较。他们的决策依据都是“如果这个元素的排序关键字比另一个元素的排序关键字小，那么就进行相应操作，否则，进行其他操作或者什么也不做。”假如我们还是依赖这一规则，无论是简单或复杂的算法或者还没被发现的算法都无法突破这一下界（最坏情况下所需要的最小时间）。所以我们需要更改游戏规则，不让算法利用比较来进行排序。 计数排序假设我们有一个数组，该数组内的元素都是 0~m-1 范围内的整数。例如 let array = [4, 1, 5, 0, 1, 6, 5, 1, 5, 3] 。如果我们可以知道排序关键字为 5 的元素有三个，并且刚好有 6 个元素的排序关键字小于 5，那么三个 5 应该位于位置6、7、8上。 首先我们要计算出有多少个元素的排序关键字等于某个值。比如有 3 个元素的排序关键字等于 5。 123456789101112131415161718// m:定义了数组array中元素的取值范围 0~m-1function countKeysEqual(array, m) &#123; // 创建一个空数组，长度为m，给每个元素赋值0 // 为什么要有这一步，万一哪个值array里没有就会变成NaN let equal = []; for (let i = 0; i &lt; m; i++) &#123; equal[i] = 0; &#125;; for (let j = 0; j &lt; array.length; j++) &#123; // 把array中的元素作为equal数组的索引值 // 该索引值在equal中对应的值为该元素在array中出现的次数 let key = array[j]; equal[key] += 1; &#125; return equal;&#125; 接着我们计算出有多少个元素的排序关键字小于该值。比如有 6 个元素的排序关键字小于 5. 1234567891011// equal 为上个函数返回的数组function countKeysLess(equal, m) &#123; let less = []; less[0] = 0; for (let i = 1; i &lt; m; i++) &#123; // less[i] = equal[0] + equal[1] + ... + equal[i - 1] less[i] = less[i - 1] + equal[i - 1]; &#125; return less;&#125; 一旦得到less数组，我们就可以知道每个元素应该放在哪个位置。 12345678910111213141516// 根据less可以得知元素在数组中的位置// 重排数组function rearrange(array, less, m) &#123; let arrB = []; for (let i = 0; i &lt; array.length; i++) &#123; let key = array[i]; // 有几个小于key的元素排在key前面，则为key值在arrB中的索引 // 比如数组[0, 1, 1, 2]，有3个排序关键字小于2，则2的索引为3 let index = less[key]; arrB[index] = array[i]; // 自增1，相同值的元素排在该值后一位 less[key] += 1; &#125; return arrB;&#125; 把三个函数组合在一起构成计数排序。 1234567// m:定义了数组array中元素的取值范围 0~m-1function countSort(array, m) &#123; let equal = countKeysEqual(array, m); let less = countKeysLess(equal, m); let arrB = rearrange(array, less, m); return arrB;&#125; 计数排序能够超越比较排序的下界，因为它从来不会对排序关键字进行比较。反之，它将排序关键字作为数组的索引，能进行这样的操作是因为排序关键字均是非常小的整数。如果排序关键字是带有分数的实数，或者是字符串，那么我们就不能使用计数排序了。","categories":[],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/tags/algorithms/"},{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]},{"title":"《Algorithms Unlocked》读书笔记2——二分查找和排序算法","slug":"《Algorithms-Unlocked》读书笔记2——二分查找和排序算法","date":"2017-04-16T12:43:49.000Z","updated":"2017-04-16T12:43:49.000Z","comments":true,"path":"2017/04/16/《Algorithms-Unlocked》读书笔记2——二分查找和排序算法/","link":"","permalink":"http://yoursite.com/2017/04/16/《Algorithms-Unlocked》读书笔记2——二分查找和排序算法/","excerpt":"《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础，算是啃CLRS前的开胃菜和辅助教材。如果CLRS的厚度让人望而生畏，这本200多页的小读本刚好合适带你入门。 书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。 二分查找在排好序的数组中查找目标值x。在p到r区间中，总是取索引为q的中间值与x进行比较，如果array[q]大于x，则比较p到q-1区间，否则比较q+1到r区间，直到array[q]等于x或p&gt;r。 1234567891011121314151617181920212223// 利用二分法在已经排好序的数组中查找值xfunction binarySearch(array, x) &#123; let p = 1; let r = array.length - 1; while (p &lt;= r) &#123; let q = Math.round((p + r) / 2); //四舍五入取整 if (array[q] === x) &#123; return q; &#125; else &#123; if (array[q] &gt; x) &#123; // 如果q没有减一，遇到找不到x的情况， // 就会陷入while循环中出不来，因为p会一直等于r r = q - 1; &#125; else &#123; p = q + 1; &#125; &#125; &#125; return 'NOT-FOUND';&#125;","text":"《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础，算是啃CLRS前的开胃菜和辅助教材。如果CLRS的厚度让人望而生畏，这本200多页的小读本刚好合适带你入门。 书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。 二分查找在排好序的数组中查找目标值x。在p到r区间中，总是取索引为q的中间值与x进行比较，如果array[q]大于x，则比较p到q-1区间，否则比较q+1到r区间，直到array[q]等于x或p&gt;r。 1234567891011121314151617181920212223// 利用二分法在已经排好序的数组中查找值xfunction binarySearch(array, x) &#123; let p = 1; let r = array.length - 1; while (p &lt;= r) &#123; let q = Math.round((p + r) / 2); //四舍五入取整 if (array[q] === x) &#123; return q; &#125; else &#123; if (array[q] &gt; x) &#123; // 如果q没有减一，遇到找不到x的情况， // 就会陷入while循环中出不来，因为p会一直等于r r = q - 1; &#125; else &#123; p = q + 1; &#125; &#125; &#125; return 'NOT-FOUND';&#125; 也可以把二分查找写成递归风格。 123456789101112131415161718192021// 二分法递归风格function recursiveBinarySearch(array, p, r, x) &#123; if (p &gt; r) &#123; // 基础情况 console.log('NOT-FOUND'); return; &#125; let q = Math.round((p + r) / 2); if (array[q] === x) &#123; // 基础情况 console.log(q); return; &#125; else &#123; if (array[q] &gt; x) &#123; recursiveBinarySearch(array, p, q-1, x); &#125; else &#123; recursiveBinarySearch(array, q+1, r, x); &#125; &#125;&#125; 排序选择排序从第一个元素开始遍历，把该元素跟在它之后的所有元素进行比较，选出最小的元素放入该位置。 以书架上的书本排序为例。我们看一眼书架上的第一本书的书名，接着与第二本进行比较，如果第二本书的书名第一个字母的顺序小于第一本，那我们忘掉第一本书的书名，记下第二本书的书名，此时我们并没有对书籍进行移动，只是比较了书名的顺序，并把顺序最小的书名记在脑子里。直到与最后一本进行比较结束，我们把脑子里顺序最小的书名对应的书与第一本书对调了一下位置。 1234567891011121314151617function selectionSort (array) &#123; for (let i = 0; i &lt; array.length - 1; i++) &#123; let smallest = i; let key = array[i]; // 保存当前值 for (let j = i + 1; j &lt; array.length; j++) &#123; // 比较当前值和最小值，如果当前值小于最小值则把当前值的索引赋给smallest if (array[j] &lt; array[smallest]) &#123; smallest = j; &#125; &#125; // 最小值和当前值交换 array[i] = array[smallest]; array[smallest] = key; &#125; return array;&#125; 选择排序效率很低，因为选择排序进行了较多的比较操作，但移动元素的操作次数很少。所以当遇到移动元素相当耗时——或者它们所占空间很大或者它们存储在一个存储较慢的设备中——那么选择排序可能是一个合适的算法。 插入排序以书架为例，假设前4个位置已经排好序了，我们拿起第五本书与第四本进行比较，如果第四本大于第五本，把第四本向右移动一个位置，再把第三本与第五本进行比较，如果第三本还大于第五本，把第三本向右移动一个位置，刚好放入第四本空出来的位置。直到遇到一本小于第五本的书或者已经没有书可以比较了，把第五本书插入小于它的那本书的后面。 12345678910111213141516function insertionSort (array) &#123; for (let i = 1; i &lt; array.length; i++) &#123; let key = array[i]; // 把当前操作值保存到key中 let j = i - 1; // j 为当前值的前一位 // 在j大于等于0且前一位大于当前值时，前一位向右移动一个位置 while (j &gt;= 0 &amp;&amp; array[j] &gt; key) &#123; array[j+1] = array[j]; j -= 1; &#125;; // 直到遇到array[j]小于当前操作值或者j小于0时，把当前值插入所空出来的位置 array[j+1] = key; &#125; return array;&#125; 插入排序与选择排序时间差不多，如果移动操作太过耗时最好用选择排序。插入排序适用于数组一开始就已经“基本有序”的状态。 归并排序归并排序中使用一个被称为分治法的通用模式。在分治法中，我们将原问题分解为类似原问题的子问题，并递归的求解这些子问题，然后再合并这些子问题的解来得出原问题的解。 分解：把一个问题分解为多个子问题，这些子问题是更小实例上的原问题。 解决：递归地求解子问题。当子问题足够小时，按照基础情况来求解。 合并：把子问题的解合并成原问题的解。 在归并排序中，我们把数组不断用二分法分解成两个小数组，直到每个数组只剩一个元素（基础情况）。再把小数组排好序并进行合并。 1234567891011121314151617181920// array: 数组// p: 开始索引// r: 末尾索引function mergeSort (array, p, r) &#123; if (p &gt;= r) &#123; return; &#125; else &#123; // 不可以用四舍五入，找了一夜的bug竟然是因为四舍五入这个小蹄子 let q = Math.floor((p + r) / 2); // 递归调用，把数组拆分成两部分，直到每个数组只剩一个元素 mergeSort(array, p, q); mergeSort(array, q + 1, r); // 把两个子数组排序并合并 merge(array, p, q, r); &#125; return array;&#125; 程序的真正工作发生在 merge 函数中。归并排序不是原址的。 假设有两堆已经排好序的书，书堆A和书堆B。把A中的第一本与B中的第一本拿起来比较，小的那本放入书架中，再把A中的“第一本”和B中的“第一本”进行比较，此时的“第一本”不一定是刚才的第一本了，因为已经有一本书放入书架了，不过该书堆的“第一本”任然是该书堆中最小的一本。直到把两堆书全部放入书架。 123456789101112131415161718192021222324252627282930function merge (array, p, q, r) &#123; let n1 = q - p + 1; // 子数组的长度 let n2 = r - q; // 把两个子数组拷贝到B、C数组中 // slice不包含end参数，所以end参数要加一 let arrB = array.slice(p, q + 1); let arrC = array.slice(q + 1, r + 1); // 两个数组的最后一个元素设为无穷大值，确保了无需再检查数组中是否有剩余元素 arrB[n1] = Number.MAX_VALUE; arrC[n2] = Number.MAX_VALUE; // 因为回填入原数组的个数是固定的，所以无穷大值不会被填入，也无需判断是否有剩余 // 一旦B、C两个数组中的所有元素拷贝完就自动终止 // 因为B、C中的元素已经按照非递减顺序排好了，所以最小索引值对应的就是最小值 // 两个子数组的最小值比较，小的则为当前最小值 let i = j = 0; for (let k = p; k &lt; r + 1; k++) &#123; if (arrB[i] &lt; arrC[j]) &#123; array[k] = arrB[i]; i++; &#125; else &#123; array[k] = arrC[j]; j++; &#125; &#125; return;&#125; 由于归并排序不是在原址上工作，需要拷贝出子数组，如果你的储存空间较小或空间非常宝贵，可能不适合使用归并排序。 快速排序与归并排序类似，快速排序也是使用分治模式。与归并排序不同的是，快速排序是在原址上工作的，归并排序是拷贝出两个子数组进行操作并不在原址上工作。 在书架中随机挑选一本书作为主元（这里我们总是选择位于书架最末尾的那本书），所有小于主元的书放在主元左侧，所有大于或等于主元的书放在主元右侧，这时就把书分为左右两组（不包括主元），再分别对这两组书进行相同的操作（递归），直到子数组只剩一本书触发基础情况。 123456789101112131415function quickSort (array, p, r) &#123; if (p &gt;= r) &#123; return; &#125; else &#123; let q = partition(array, p, r); // 递归中不再包含array[q]，因为它已经处在正确的位置（左边所有元素都小于它，右边所有元素都大于或等于它） // 如果递归调用还包含array[q]，就会陷入死循环 quickSort(array, p, q - 1); quickSort(array, q + 1, r); &#125; return array;&#125; 重要的操作都在 partition 函数中。这个函数把数组按照大于或小于主元分为左右两堆，并返回主元所在位置的索引q。注意，左右两堆数组并不是有序的（见上图），只是大于或小于主元。 在书架中随机挑选一本书作为主元（这里我们总是选择位于书架最末尾的那本书），此时主元位于最末尾。还未进行比较的为未知组，称为组U，位于主元左侧。小于主元的称为组L，位于书架最左侧。大于或小于主元的称为组R，位于组L左侧组U右侧。如下图。 我们拿起组U中最左侧的那本书，与主元进行比较，如果小于主元则放入组L，大于或等于主元则放入组R。放入组R的操作比较简单，只需要把组R和组U的分割线往右移一位，无需移动书籍。 放入组L的操作则比较复杂。我们将它与组R中最左侧的书籍进行调换，并将组L和组R之间的分割线向右移一位，将组R和组U的分割线向右移一位。如下图 12345678910111213141516171819202122232425262728293031// 主元：数组中随机挑选单独的一个数（这里我们总是选数组中的最后一位）array[r]// 组L（左侧组）：所有小于主元的数，array[p...q-1]// 组R（右侧组）：所有大于或等于主元的数，array[q...u-1]// 组U（未知组）：还未进行比较的数，array[u...r-1]function partition(array, p, r) &#123; let q = p; // 遍历array[p...r-1] for (let u = p; u &lt; r; u++) &#123; // 如果未知数小于主元，放入组L if (array[u] &lt; array[r]) &#123; // 把未知数和组R最左侧值(array[q])进行交换，并让q和u往右移一位(加1) let key = array[q]; array[q] = array[u]; array[u] = key; q += 1; &#125; // 如果未知数大于或等于主元，放入组R // 无需其他操作，只需要把u往右移一位 &#125; // 把主元和组R最左侧值(array[q])进行交换，让主元位于组L合组R中间 let key = array[q]; array[q] = array[r]; array[r] = key; return q;&#125; 本例的快速排序总是选择最末尾的元素作为主元，称为确定的快速排序。如果每次选择主元时都从数组中随机选择，则称为随机快速排序，随机快速排序在测试中会快于确定的快速排序。 根据数据量的不同，储存空间的大小，存储速度的快慢，每个排序方法都有不同的表现，并不是说哪个方法一定是最快的，也不一定最快就是最好的，合适才是最好的。","categories":[],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/tags/algorithms/"},{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]},{"title":"《Algorithms Unlocked》读书笔记1——循环和递归","slug":"《Algorithms-Unlocked》读书笔记1——循环和递归","date":"2017-04-10T13:35:03.000Z","updated":"2017-04-10T13:35:03.000Z","comments":true,"path":"2017/04/10/《Algorithms-Unlocked》读书笔记1——循环和递归/","link":"","permalink":"http://yoursite.com/2017/04/10/《Algorithms-Unlocked》读书笔记1——循环和递归/","excerpt":"《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础。 书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。 循环和查找首先是三个简单的查找。目的是从数组中查找一个特定的值。 array: 一个数组 x: 要查找的值 1234567891011121314// 简单的线性查找function linearSearch(array, x) &#123; let answer = 'NOT-FOUND'; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] === x) &#123; // 虽然找到了i, 但没有返回继续查找，直到 for 结束 answer = i; &#125; &#125; console.log(answer); return;&#125; 虽然找到了目标值，但for循环依然继续遍历直到结束，下面是优化","text":"《Algorithms Unlocked》是 《算法导论》的合著者之一 Thomas H. Cormen 写的一本算法基础。 书中没有涉及编程语言，直接用文字描述算法，我用 JavaScript 对书中的算法进行描述。 循环和查找首先是三个简单的查找。目的是从数组中查找一个特定的值。 array: 一个数组 x: 要查找的值 1234567891011121314// 简单的线性查找function linearSearch(array, x) &#123; let answer = 'NOT-FOUND'; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] === x) &#123; // 虽然找到了i, 但没有返回继续查找，直到 for 结束 answer = i; &#125; &#125; console.log(answer); return;&#125; 虽然找到了目标值，但for循环依然继续遍历直到结束，下面是优化 1234567891011121314// 优化的查找，找到目标后立刻返回function betterLinearSearch(array, x) &#123; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] === x) &#123; // 直接返回 console.log(i); return; &#125; &#125; console.log('NOT-FOUND'); return;&#125; 还有一个问题是：假如直到最后都没有找到目标值，将试图访问越过数组末尾的元素。书上说：“在计算机程序中，当你试图访问越过数组末尾的元素时，结果通常是糟糕的。你的程序可能会崩溃，也可能会损坏数据。” 宁可信其有，不可信其无啊。继续优化。 12345678910111213141516171819202122232425// 更优的写法// 总是让 for 循环可以结束function sentinelLinearSearch(array, x) &#123; let n = array.length - 1; // 最后一个元素 // 把数组最后一个值保存到last变量中 let last = array[n] // 把数组最后一个值替换成目标值 array[n] = x; // 判断数组中是否有目标值x，即使没有，数组的最后一个值也一定是目标值，避免越过数组末尾的访问 let i = 0; while (array[i] !== x) &#123; i++; &#125; //如果i小于数组长度，或者最后一个值为目标值x，则返回i array[n] = last; if (i &lt; n || last === x) &#123; console.log(i); return; &#125; return 'NOT-FOUND';&#125; 第三个方案在进行循环遍历的时候只进行了一个判断——array[i]是否等于x，而上面的两种方案在进行for循环时都要进行i是否大于length的判断和array[i]是否等于x两个判断。所以当数组大到一定程度的时候，第三个方案效率大于上面两个方案。 递归递归是指在函数中对函数自身进行调用。 递归有两个特性： 必须有一个或对个基础情况，它是指不用递归而直接计算出结果。比如下面例子中：当 n=0 时，基础情况发生，f(0) = 1; 程序中的每个递归调用一定是通过一系列关于同一个问题的子问题的求解而最终迭代到基础情况。 下面是一个经典的递归例子，计算阶乘。 当n=0时，n! = 1 且 n! = n(n-1)(n-2)…3•2•1 (n≥0) 比如：5! = 5•4•3•2•1 = 120 123456789// 阶乘function factorial(n) &#123; if (n &gt;= 0) &#123; if (n === 0) &#123; return 1; &#125;; return n * factorial(n - 1); &#125;;&#125; 之前的查找算法也可以写成递归风格 123456789101112131415// 线性查找的递归风格function recursiveLinearSearch(array, i, x) &#123; if (i &lt; array.length) &#123; if (array[i] === x) &#123; console.log(i); return; &#125;else &#123; return recursiveLinearSearch(array, i+1, x); &#125; &#125; console.log('NOT-FOUND'); return;&#125;","categories":[],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/tags/algorithms/"},{"name":"read","slug":"read","permalink":"http://yoursite.com/tags/read/"}]},{"title":"Git 的简单使用","slug":"Git-的简单使用","date":"2016-11-20T11:59:39.000Z","updated":"2016-11-20T11:59:39.000Z","comments":true,"path":"2016/11/20/Git-的简单使用/","link":"","permalink":"http://yoursite.com/2016/11/20/Git-的简单使用/","excerpt":"一直在使用Git，仅限于简单的使用，但还是记不住几个简单。在这边总结一下，加深印象，也方便查找。 安装Git平常主要在windows和ubuntu上工作，就以windows为例，Linux和Mac平台应该也差不多，反而是windows上坑比较多。 在windows上首先要下载Git，谷歌上搜一下，傻瓜式下载安装。Linux上不同发行版会有点小差异，不过你可以输入git，系统会提示你如何进行安装。 我们可以简单的把Git看成三个部分：本地、暂存区、远程仓库。下面我们来简单介绍各部分的作用。 存入暂存区","text":"一直在使用Git，仅限于简单的使用，但还是记不住几个简单。在这边总结一下，加深印象，也方便查找。 安装Git平常主要在windows和ubuntu上工作，就以windows为例，Linux和Mac平台应该也差不多，反而是windows上坑比较多。 在windows上首先要下载Git，谷歌上搜一下，傻瓜式下载安装。Linux上不同发行版会有点小差异，不过你可以输入git，系统会提示你如何进行安装。 我们可以简单的把Git看成三个部分：本地、暂存区、远程仓库。下面我们来简单介绍各部分的作用。 存入暂存区 在命令行中进入该目录，输入 git init 命令，该命令会把本地文件夹变成Git可以管理的仓库，主要是生成 .git 文件。 git add fileName 命令可以添加想要上传的文件，比如添加 readme.md 就输入 git add readme.md，这个命令可以多次重复使用，添加多个文件。如果要添加一整个文件夹也是同理， git add 文件夹名。比如 git add images。 把添加的文件上传至暂存区，并附上说明：git commit -m &quot;add readme&quot;。 经过这三步就可以把本地文件上传至暂存区。这个时候如果我们在修改本地文件时不小心改乱了，还可以执行版本退回，也可以执行撤销修改，删除文件等操作。由于是简单的入门教程，本文不展开讨论。 添加SSH key之前的操作都是在本地上进行的，现在我们需要把暂存区的文件提交到GitHub仓库中。 首先我们需要有一个GitHub账号，然后利用ssh秘钥，让GitHub可以识别你的电脑。 在本地创建SSH Key: $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 把邮箱地址换成你自己的地址，然后一路回车，之后你就可以再用户主目录中找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，id_rsa 是私钥，不可以泄露，id_rsa.pub 是公钥，我们需要把它复制到GitHub中。 登录你的GitHub账号，在settings中找到SSH and GPG keys选项，点击New SSH key，把 id_rsa.pub 中的内容复制到Key中，并取一个title。点击Add SSH key就完成了。 如果你有多个电脑，可以添加多个key，一个电脑对应一个KEY。光是让GitHub认得这是你的电脑还不够，我们还要把本地仓库与远程仓库进行绑定。 本地仓库其实就是本地文件夹，但我们还没有建立远程仓库，接下来教大家如何建立远程仓库。 创建远程仓库在你的GitHub的头像旁边有一个加号，点击加号在选择New repository,填好Repository name和Description，点击Create repository，一个远程仓库就建立好了。 接下来我们要把本地仓库与远程仓库进行绑定，在本地仓库文件夹中执行： $ git remote add origin git@github.com:yourName/repositoryName.git 把 yourName 换成你的GitHub的账户名，把repositoryName换成刚刚建好的远程仓库名，就可以把本地仓库与远程仓库进行绑定。 本地仓库和远程仓库的名称并不一定要相同，不过相同的名称方便我们管理。 这时我们就可以把本地仓库的内容推送至远程仓库了： $ git push -u origin master 第一次推送时我们加上 -u 参数，可以把本地的 master 分支和远程的 master 分支关联起来，以后就可以简化我们的推送命令。 $ git push origin master 至此，我们已经完成了从本地到远程的所有操作，基本可以满足平时的使用。 题外话如果你在windows上进行工作，我建议使用GitHub的桌面端，因为windows上总是会有一些奇奇怪怪的错误。比如你的用户文件夹是中文名，就会产生问题，而解决这些莫名其妙的问题其实是在浪费时间，最好的解决办法就是换个用户名或者换台电脑。GitHub的桌面端简单易用，不需要我们手动绑定SSH key，只需登录账户就可以使用了。 如果你是新手，遇到难以解决的问题，在试图解决问题但没有成功也没有人能够帮助你的时候，可以先把本地仓库先备份到其他地方，然后删除掉你的本地仓库，重新从远程仓库克隆一份，再进行操作。克隆的命令如下： $ git clone git@github.com:yourName/repositoryName.git 这个方法可以帮助你解决一部分问题，但不保证你遇到的所有问题都能解决。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"浅谈JavaScript中的apply、call、bind","slug":"浅谈JavaScript中的apply、call、bind","date":"2016-11-17T07:17:19.000Z","updated":"2016-11-17T07:17:19.000Z","comments":true,"path":"2016/11/17/浅谈JavaScript中的apply、call、bind/","link":"","permalink":"http://yoursite.com/2016/11/17/浅谈JavaScript中的apply、call、bind/","excerpt":"apply,call,bine 这三兄弟经常让初学者感到疑惑。前两天准备面试时特地做了个比较，其实理解起来也不会太难。 applyMDN上的定义：The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object). apply() 方法调用一个函数，指定该函数的 this 值并将一个数组（或类数组对象）作为该函数的参数。 语法 (Syntax)fun.apply(thisArg,[argsArray]) 直接上代码123456function sayColor(arg) &#123; var color = \"red\"; console.log(arg + this.color);&#125;var obj = &#123;color: \"blue\"&#125;;sayColor.apply(obj, [\"The color is\"]); //输出\"The color is blue\" 此时 this 指向 obj ，则 this.color 为 obj 的 color 属性，则输出 The color is blue。","text":"apply,call,bine 这三兄弟经常让初学者感到疑惑。前两天准备面试时特地做了个比较，其实理解起来也不会太难。 applyMDN上的定义：The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object). apply() 方法调用一个函数，指定该函数的 this 值并将一个数组（或类数组对象）作为该函数的参数。 语法 (Syntax)fun.apply(thisArg,[argsArray]) 直接上代码123456function sayColor(arg) &#123; var color = \"red\"; console.log(arg + this.color);&#125;var obj = &#123;color: \"blue\"&#125;;sayColor.apply(obj, [\"The color is\"]); //输出\"The color is blue\" 此时 this 指向 obj ，则 this.color 为 obj 的 color 属性，则输出 The color is blue。 callcall() 与 apply() 类似，区别在于 apply() 的第二个参数为数组，而 call() 把参数跟在第一个参数后面，并且可以跟多个参数。 语法 (Syntax)fun.call(thisArg, arg1, arg2, arg3 ...) 看代码12345function sayClothe(arg1,arg2) &#123; console.log(arg1 + this.color + arg2);&#125;var obj = &#123;color: \"blue\"&#125;;sayClothe.call(obj, \"This is a \", \" clothe\" ); //输出\"This is a blue clothe\" bindbind() 与 call() 类似，有一点不同在于 bind() 返回一个新函数(new function)，我们可以随时调用该函数。 语法(Syntax)fun.bind(thisArg, arg1, arg2, arg3 ...) 返回值返回一个具有指定 this 和初始参数的函数副本。 看代码 123456function sayClothe(arg1, arg2) &#123; console.log(arg1 + this.color + arg2);&#125;var obj = &#123;color: \"blue\"&#125;;var sayClothe2 = sayClothe.bind(obj, \"This is a \", \" clothe\");sayClothe2(); //输出 \"This is a blue clothe\" 使用有时候我们会碰到 Array.prototype.slice.call(arguments) 这种用法。许多人会疑惑，直接使用 arguments.slice() 不就行了吗，为什么要多此一举。 原因在于，arguments 并不是真正的数组对象，只是 array-like object ，所以它并没有 slice 这个方法。而 Array.prototype.slice.call(arguments) 可以理解为把 slice 的对象指向 arguments ,从而让 arguments 可以使用 slice 方法。如果直接使用 arguments.slice() 则会报错。 bind() 的另一个用法则是让函数拥有预设参数，而又跟预设参数有所不同。 以下例子结合上面两条规则 本例出自MDN 1234567891011121314function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); //[1, 2, 3]//Create a function with a preset leading argumentsvar leadingThirtysevenList = list.bind(null, 37);var list2 = leadingThirtysevenList();//[37]var list3 = leadingThirtysevenList(1, 2, 3);//[37, 1, 2, 3] 我们想到预设参数就会理所当然的想到 “如果该函数没有参数就使用预设参数，有参数就使用提供的参数”。不过 bind() 所提供的预设参数功能与此不同。 在我们的印象中， list3 应该输出 [1, 2, 3] 但实际输出的却是 [37, 1, 2, 3]。因为 bind() 的特点，leadingThirtysevenList(1, 2, 3) 可以写为 list.bind(null, 37, 1, 2, 3)。 总结apply() call() bind() 三者区别不大，都是用来改变函数的 this 指向。 apply() 把 this 所需参数放入一个数组，作为 apply() 的第二个参数传入。当参数不定时，我们可以传入 arguments。 call() 和 bind() 则把参数按顺序依次传入。 bind() 返回对应函数，便于稍后调用，而 apply()、call()则立即调用 由于其特性，使用起来千奇百怪，有各种各样有趣的用法，还等待我们去挖掘。","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]}]}